{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js"],"names":["Object","defineProperty","exports","value","call","key","opts","this","debug","node","_call","type","fns","fn","ret","state","then","Error","_traverseFlags","isBlacklisted","isDenylisted","_this$opts$denylist","denylist","blacklist","indexOf","visit","shouldSkip","shouldStop","_index","default","scope","skipKeys","skip","skipKey","stop","_index2","SHOULD_SKIP","SHOULD_STOP","setScope","noScope","target","path","parentPath","isMethod","getScope","init","setContext","context","resync","removed","_resyncParent","_resyncList","_resyncKey","parent","container","Array","isArray","i","length","setKey","keys","inList","newContainer","listKey","_resyncRemoved","_markRemoved","popContext","contexts","pop","undefined","pushContext","push","setup","_this$node","requeue","pathToQueue","maybeQueue","_getQueueContexts","obj","require","__esModule","remove","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","bindings","getBindingIdentifiers","forEach","name","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","_replaceWith","REMOVED","_cache","get","delete","buildCodeFrameError","cache","_getRequireWildcardCache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","prototype","hasOwnProperty","desc","set","_interopRequireWildcard","WeakMap","self","isWhile","isSwitchCase","isExportDeclaration","isLabeledStatement","isVariableDeclaration","declarations","isExpressionStatement","isSequenceExpression","expressions","replaceWith","isBinary","right","left","isIfStatement","isLoop","isArrowFunctionExpression","body","insertBefore","nodes_","nodes","_verifyNodeList","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","replaceExpressionWithStatements","_containerInsertBefore","isStatementOrBlock","shouldInsertCurrentNode","expression","t","blockStatement","unshiftContainer","_containerInsert","from","paths","to","getSibling","queue","_containerInsertAfter","insertAfter","map","isExpression","expressionStatement","isPattern","assertExpression","callExpression","arrowFunctionExpression","computed","temp","generateDeclaredUidIdentifier","unshift","assignmentExpression","cloneNode","pushContainer","fromIndex","incrementBy","msg","verifiedNodes","replaceWithMultiple","hoist","hoister","_hoister","run","_interopRequireDefault","referenceVisitor","ReferencedIdentifier","isJSXIdentifier","react","isCompatTag","isJSXMemberExpression","isFunction","breakOnScopePaths","binding","getBinding","constantViolations","mutableBinding","PathHoister","scopes","attachAfter","bindingIdentifierEquals","identifier","isCompatibleScope","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","_blockHoist","isStatement","constant","traverse","getCompatibleScopes","attachTo","getAttachmentPath","getFunctionParent","uid","generateUidIdentifier","declarator","variableDeclarator","isVariableDeclarator","variableDeclaration","attached","children","jsxExpressionContainer","getOpposite","getCompletionRecords","addCompletionRecords","isDoExpression","isFor","isBlockStatement","isTryStatement","isCatchClause","isSwitchStatement","cases","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","parts","split","_getKey","_getPattern","_","part","duplicates","getOuterBindingIdentifiers","getBindingIdentifierPaths","outerOnly","search","concat","ids","create","id","shift","isIdentifier","_ids","declaration","isFunctionDeclaration","isFunctionExpression","child","getOuterBindingIdentifierPaths","statements","_findBreak","_findBreak2","isBreakStatement","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","line","comments","explode","verify","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","enter","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","console","trace","alias","existing","assign","_verified","validateVisitorMethods","TYPES","visitorKey","val","TypeError","oldVisitor","newVisitor","newFn","toString","exit","checkPath","apply","arguments","dest","src","Hub","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","isReferenced","isMemberExpression","grandparent","isBinding","isForXStatement","isReferencedIdentifier","isScope","isBlockScoped","isVar","loc","isUser","isPure","isFlow","isImportDeclaration","importKind","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","source","specifiers","isModuleSpecifier","local","isLiteral","object","property","callee","properties","argument","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","getProgramParent","registerBinding","Declaration","registerDeclaration","references","ForXStatement","ExportDeclaration","isClassDeclaration","reference","decl","LabeledStatement","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","CatchClause","Function","NOT_LOCAL_BINDING","params","param","ClassExpression","block","labels","inited","globals","uids","data","crawling","cached","Map","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","join","slice","generateUidBasedOnNode","isThisExpression","isSuper","dontPush","isStatic","generateUidIdentifierBasedOnNode","hub","buildError","oldName","newName","rename","sep","repeat","log","violations","arrayLikeIsIterable","isGenericType","isArrayExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","label","registerLabel","specifier","unaryExpression","reassign","bindingPath","ReferenceError","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClass","superClass","isClassBody","method","elements","elem","prop","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","isPureish","crawl","programParent","typeVisitors","addGlobal","ref","ensureBlock","unique","blockHoist","dataKey","declarPath","getData","setData","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","_parent","isKey","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","enumerable","_path","_scope","_hub","_context","VISITOR_KEYS","_default","hasDenylistedType","cheap","traverseFast","clearNode","removeProperties","tree","hasType","denylistTypes","TraversalContext","priorityQueue","notPriority","trap","shouldVisit","visitQueue","visited","WeakSet","process","add","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","NodePath","def","SyntaxError","validate","message","enabled","getPathLocation","code","v","targetNode","typeKey","virtualType","findParent","callback","p","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","_pathCache$get","inheritLeadingComments","inheritTrailingComments","replaceWithSourceString","replacement","_parser","parse","err","_codeFrame","codeFrameColumns","start","column","nodePath","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","oldNode","inheritsComments","removeComments","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","hoistVariablesVisitor","completionRecords","loop","returnStatement","arrowFunctionToExpression","FUNCTION_TYPES","awaitExpression","replaceInline","VariableDeclaration","exprs","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","resolved","item","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","_evaluate","raw","str","cooked","expr","String","toComputedKey","stringLiteral","bodyNode","stringPath","arrowFunctionToShadowed","unwrapFunctionEnvironment","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","isnt","equals","isType","isCompletionRecord","allowInsideFunction","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex"],"mappings":"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","file":"static/js/vendors-runtime-traverse.9fddfd4d.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = _interopRequireWildcard(require(\"./index\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}"],"sourceRoot":""}