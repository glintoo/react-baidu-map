{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"],"names":["Object","defineProperty","exports","value","replaceWithMultiple","nodes","_pathCache$get","this","resync","_verifyNodeList","t","inheritLeadingComments","node","inheritTrailingComments","length","_cache","path","get","parent","delete","container","key","paths","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","parse","err","loc","message","_codeFrame","codeFrameColumns","start","line","column","code","program","body","expression","_index","default","removeProperties","replaceWith","removed","Error","_index2","isProgram","Array","isArray","nodePath","isNodeType","isExpression","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","parentPath","isExportDefaultDeclaration","expressionStatement","isStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","type","setScope","_pathCache$get2","ReferenceError","inList","validate","debug","set","toSequenceExpression","scope","functionParent","getFunctionParent","isParentAsync","is","arrowFunctionExpression","blockStatement","callExpression","traverse","hoistVariablesVisitor","completionRecords","getCompletionRecords","isExpressionStatement","loop","findParent","isLoop","uid","getData","identifier","name","callee","generateDeclaredUidIdentifier","pushContainer","returnStatement","cloneNode","setData","assignmentExpression","arrowFunctionToExpression","hasType","FUNCTION_TYPES","awaitExpression","replaceInline","_containerInsertAfter","require","_interopRequireDefault","obj","__esModule","cache","_getRequireWildcardCache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","prototype","hasOwnProperty","call","desc","_interopRequireWildcard","WeakMap","Function","skip","VariableDeclaration","kind","bindings","getBindingIdentifiers","keys","push","id","exprs","declarations","declar","init","evaluateTruthy","res","evaluate","confident","state","deoptPath","seen","Map","evaluateCached","undefined","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","val","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","property","isIdentifier","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","isCallExpression","isLiteral","isReferencedIdentifier","binding","constantViolations","end","hasValue","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elemValue","isObjectExpression","props","prop","isObjectMethod","isSpreadElement","computed","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","Math","pow","context","func","indexOf","global","args","map","apply","_evaluate","raw","str","i","elem","cooked","expr","String","toComputedKey","isProperty","isMethod","stringLiteral","ensureBlock","bodyNode","isBlockStatement","listKey","statements","stringPath","setup","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","generateUidIdentifier","objectExpression","unshiftContainer","hub","addHelper","thisExpression","memberExpression","_helperFunctionName","fnPath","thisEnvFn","p","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","CallExpression","isSuper","superBinding","getSuperBinding","forEach","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","slice","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","parts","numericLiteral","sequenceExpression","isClassMethod","superClass","supers","WeakSet","add","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","method","unshift","valueIdent","cacheKey","data","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","ReferencedIdentifier","MetaProperty","matchesPattern","pattern","allowPartial","isStatic","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","first","isStatementOrBlock","isLabeledStatement","STATEMENT_OR_BLOCK_KEYS","includes","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","target","_guessExecutionStatusRelativeTo","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","getAncestry","commonIndex","isExecutionUncertainInList","divergence","VISITOR_KEYS","keyPosition","parentKey","isExportDeclaration","references","allStatus","referencePaths","find","executionOrderCheckedNodes","status","dangerous","_resolve","isVariableDeclarator","constant","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","getProgramParent","isExecutionUncertain","maxIndex","opts","_call","fns","fn","then","_traverseFlags","isBlacklisted","isDenylisted","_this$opts$denylist","denylist","blacklist","visit","shouldSkip","shouldStop","skipKeys","skipKey","stop","SHOULD_SKIP","SHOULD_STOP","noScope","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","popContext","contexts","pop","pushContext","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","REMOVED","self","isWhile","isSwitchCase","isVariableDeclaration","expressions","isBinary","isIfStatement","insertBefore","nodes_","isExportNamedDeclaration","isDeclaration","isJSXElement","isForStatement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","queue","isPattern","assertExpression","temp","fromIndex","incrementBy","msg","verifiedNodes","hoist","hoister","_hoister","run","referenceVisitor","isJSXIdentifier","react","isCompatTag","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","bindingIdentifierEquals","isCompatibleScope","_getAttachmentPath","targetScope","hasOwnBinding","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","_blockHoist","getCompatibleScopes","attachTo","getAttachmentPath","declarator","variableDeclarator","variableDeclaration","attached","children","jsxExpressionContainer","getOpposite","addCompletionRecords","isDoExpression","isTryStatement","isCatchClause","isSwitchStatement","cases","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","split","_getKey","_getPattern","_","part","duplicates","getOuterBindingIdentifiers","getBindingIdentifierPaths","outerOnly","search","ids","create","shift","_ids","declaration","getOuterBindingIdentifierPaths","_findBreak","_findBreak2","isBreakStatement","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","explode","verify","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","enter","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","console","trace","alias","assign","_verified","validateVisitorMethods","TYPES","visitorKey","TypeError","oldVisitor","newVisitor","newFn","toString","exit","checkPath","arguments","dest","src","Hub","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","isReferenced","grandparent","isBinding","isForXStatement","isScope","isBlockScoped","isVar","isUser","isPure","isFlow","importKind","exportKind","isObjectPattern","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","specifiers","isModuleSpecifier","local","properties","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","registerBinding","Declaration","registerDeclaration","ForXStatement","ExportDeclaration","isClassDeclaration","reference","decl","LabeledStatement","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","CatchClause","NOT_LOCAL_BINDING","params","param","ClassExpression","block","labels","inited","globals","uids","crawling","cached","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","defaultName","join","generateUidBasedOnNode","isThisExpression","dontPush","generateUidIdentifierBasedOnNode","buildError","oldName","newName","rename","sep","repeat","log","violations","arrayLikeIsIterable","isGenericType","helperName","getLabel","label","registerLabel","specifier","unaryExpression","reassign","bindingPath","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClassBody","elements","tag","isPureish","crawl","programParent","typeVisitors","addGlobal","ref","unique","blockHoist","dataKey","declarPath","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","_parent","isKey","builtin","Binding","referenced","clearValue","hasDeoptedValue","enumerable","_path","_scope","_hub","_context","_default","hasDenylistedType","cheap","traverseFast","clearNode","tree","denylistTypes","TraversalContext","priorityQueue","notPriority","trap","shouldVisit","visitQueue","visited","process","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","NodePath","def","SyntaxError","enabled","getPathLocation","v","targetNode","typeKey","virtualType","callback","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","filter","lastCommonIndex","lastCommon","minDepth","ancestry","depthLoop","shouldMatch","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","functions","inferAnnotationFromBinaryExpression","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","getParentConditionalPath"],"mappings":"iJAEAA,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,oBAqDR,SAA6BC,GAC3B,IAAIC,EAEJC,KAAKC,SACLH,EAAQE,KAAKE,gBAAgBJ,GAC7BK,EAAEC,uBAAuBN,EAAM,GAAIE,KAAKK,MACxCF,EAAEG,wBAAwBR,EAAMA,EAAMS,OAAS,GAAIP,KAAKK,MACL,OAAlDN,EAAiBS,EAAOC,KAAKC,IAAIV,KAAKW,UAA4BZ,EAAea,OAAOZ,KAAKK,MAC9FL,KAAKK,KAAOL,KAAKa,UAAUb,KAAKc,KAAO,KACvC,IAAMC,EAAQf,KAAKgB,YAAYlB,GAE3BE,KAAKK,KACPL,KAAKiB,UAELjB,KAAKkB,SAGP,OAAOH,GArETpB,EAAQwB,wBAwER,SAAiCC,GAC/BpB,KAAKC,SAEL,IACEmB,EAAc,IAAH,OAAOA,EAAP,KACXA,GAAc,EAAIC,EAAQC,OAAOF,GACjC,MAAOG,GACP,IAAMC,EAAMD,EAAIC,IAYhB,MAVIA,IACFD,EAAIE,SAAW,yCAA0C,EAAIC,EAAWC,kBAAkBP,EAAa,CACrGQ,MAAO,CACLC,KAAML,EAAIK,KACVC,OAAQN,EAAIM,OAAS,KAGzBP,EAAIQ,KAAO,8BAGPR,EAOR,OAJAH,EAAcA,EAAYY,QAAQC,KAAK,GAAGC,WAE1CC,EAAOC,QAAQC,iBAAiBjB,GAEzBpB,KAAKsC,YAAYlB,IAjG1BzB,EAAQ2C,YAoGR,SAAqBlB,GAGnB,GAFApB,KAAKC,SAEDD,KAAKuC,QACP,MAAM,IAAIC,MAAM,yDAGdpB,aAAuBqB,EAAQL,UACjChB,EAAcA,EAAYf,MAG5B,IAAKe,EACH,MAAM,IAAIoB,MAAM,6EAGlB,GAAIxC,KAAKK,OAASe,EAChB,MAAO,CAACpB,MAGV,GAAIA,KAAK0C,cAAgBvC,EAAEuC,UAAUtB,GACnC,MAAM,IAAIoB,MAAM,sEAGlB,GAAIG,MAAMC,QAAQxB,GAChB,MAAM,IAAIoB,MAAM,2FAGlB,GAA2B,kBAAhBpB,EACT,MAAM,IAAIoB,MAAM,6FAGlB,IAAIK,EAAW,GAEX7C,KAAK8C,WAAW,cAAgB3C,EAAE4C,aAAa3B,KAC5CpB,KAAKgD,0CAA6ChD,KAAKiD,qCAAqC7B,IAAiBpB,KAAKkD,WAAWC,+BAChI/B,EAAcjB,EAAEiD,oBAAoBhC,GACpCyB,EAAW,eAIf,GAAI7C,KAAK8C,WAAW,eAAiB3C,EAAEkD,YAAYjC,KAC5CpB,KAAKgD,2CAA6ChD,KAAKiD,qCAAqC7B,GAC/F,OAAOpB,KAAKsD,gCAAgC,CAAClC,IAIjD,IAAMmC,EAAUvD,KAAKK,KAEjBkD,IACFpD,EAAEqD,iBAAiBpC,EAAamC,GAChCpD,EAAEsD,eAAeF,IAQnB,OALAvD,KAAK0D,aAAatC,GAElBpB,KAAK2D,KAAOvC,EAAYuC,KACxB3D,KAAK4D,WACL5D,KAAKiB,UACE,CAAC4B,EAAW7C,KAAKU,IAAImC,GAAY7C,OA7J1CL,EAAQ+D,aAgKR,SAAsBrD,GACpB,IAAIwD,EAEJ,IAAK7D,KAAKa,UACR,MAAM,IAAIiD,eAAe,sBAGvB9D,KAAK+D,OACP5D,EAAE6D,SAAShE,KAAKW,OAAQX,KAAKc,IAAK,CAACT,IAEnCF,EAAE6D,SAAShE,KAAKW,OAAQX,KAAKc,IAAKT,GAGpCL,KAAKiE,MAAL,uBAAmC,MAAR5D,OAAe,EAASA,EAAKsD,OACJ,OAAnDE,EAAkBrD,EAAOC,KAAKC,IAAIV,KAAKW,UAA4BkD,EAAgBK,IAAI7D,EAAML,MAAMY,OAAOZ,KAAKK,MAChHL,KAAKK,KAAOL,KAAKa,UAAUb,KAAKc,KAAOT,GA9KzCV,EAAQ2D,gCAiLR,SAAyCxD,GACvCE,KAAKC,SACL,IAAMkE,EAAuBhE,EAAEgE,qBAAqBrE,EAAOE,KAAKoE,OAEhE,GAAID,EACF,OAAOnE,KAAKsC,YAAY6B,GAAsB,GAAGzD,IAAI,eAGvD,IAAM2D,EAAiBrE,KAAKsE,oBACtBC,EAAkC,MAAlBF,OAAyB,EAASA,EAAeG,GAAG,SACpE3D,EAAYV,EAAEsE,wBAAwB,GAAItE,EAAEuE,eAAe5E,IACjEE,KAAKsC,YAAYnC,EAAEwE,eAAe9D,EAAW,KAC7Cb,KAAK4E,SAASC,GACd,IAb8C,EAaxCC,EAAoB9E,KAAKU,IAAI,UAAUqE,uBAbC,IAe3BD,GAf2B,IAe9C,2BAAsC,KAA3BrE,EAA2B,QACpC,GAAKA,EAAKuE,wBAAV,CACA,IAAMC,EAAOxE,EAAKyE,YAAW,SAAAzE,GAAI,OAAIA,EAAK0E,YAE1C,GAAIF,EAAM,CACR,IAAIG,EAAMH,EAAKI,QAAQ,kCAEvB,GAAKD,EAMHA,EAAMjF,EAAEmF,WAAWF,EAAIG,UANf,CACR,IAAMC,EAASxF,KAAKU,IAAI,UACxB0E,EAAMI,EAAOpB,MAAMqB,8BAA8B,OACjDD,EAAO9E,IAAI,QAAQgF,cAAc,OAAQvF,EAAEwF,gBAAgBxF,EAAEyF,UAAUR,KACvEH,EAAKY,QAAQ,iCAAkCT,GAKjD3E,EAAKC,IAAI,cAAc4B,YAAYnC,EAAE2F,qBAAqB,IAAK3F,EAAEyF,UAAUR,GAAM3E,EAAKJ,KAAK6B,kBAE3FzB,EAAK6B,YAAYnC,EAAEwF,gBAAgBlF,EAAKJ,KAAK6B,eAjCH,8BAqC9C,IAAMsD,EAASxF,KAAKU,IAAI,UACxB8E,EAAOO,4BAEHxB,GAAiBpC,EAAOC,QAAQ4D,QAAQhG,KAAKU,IAAI,eAAeL,KAAM,kBAAmBF,EAAE8F,kBAC7FT,EAAOtB,IAAI,SAAS,GACpBlE,KAAKsC,YAAYnC,EAAE+F,gBAAgBlG,KAAKK,QAG1C,OAAOmF,EAAO9E,IAAI,cA7NpBf,EAAQwG,cAgOR,SAAuBrG,GAGrB,GAFAE,KAAKC,SAED0C,MAAMC,QAAQ9C,GAAQ,CACxB,GAAI6C,MAAMC,QAAQ5C,KAAKa,WAAY,CACjCf,EAAQE,KAAKE,gBAAgBJ,GAE7B,IAAMiB,EAAQf,KAAKoG,sBAAsBtG,GAGzC,OADAE,KAAKkB,SACEH,EAEP,OAAOf,KAAKH,oBAAoBC,GAGlC,OAAOE,KAAKsC,YAAYxC,IA7O5B,IAAI4B,EAAa2E,EAAQ,KAErBlE,EAASmE,EAAuBD,EAAQ,KAExC5D,EAAU6D,EAAuBD,EAAQ,KAEzC7F,EAAS6F,EAAQ,KAEjBhF,EAAUgF,EAAQ,KAElBlG,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAASH,EAAuBC,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAEvF,IAAM1B,EAAwB,CAC5BwC,SAD4B,SACnB5G,GACPA,EAAK6G,QAGPC,oBAL4B,SAKR9G,GAClB,GAAuB,QAAnBA,EAAKJ,KAAKmH,KAAd,CAGA,IAFA,IAAMC,EAAWhH,EAAKiH,wBAEtB,MAAkBjI,OAAOkI,KAAKF,GAA9B,eAAyC,CAApC,IAAM3G,EAAG,KACZL,EAAK2D,MAAMwD,KAAK,CACdC,GAAIJ,EAAS3G,KAIjB,IAVwB,EAUlBgH,EAAQ,GAVU,IAYHrH,EAAKJ,KAAK0H,cAZP,IAYxB,2BAA6C,KAAlCC,EAAkC,QACvCA,EAAOC,MACTH,EAAMF,KAAKzH,EAAEiD,oBAAoBjD,EAAE2F,qBAAqB,IAAKkC,EAAOH,GAAIG,EAAOC,SAd3D,8BAkBxBxH,EAAKZ,oBAAoBiI,O,mCCrD7B,Y,YAEArI,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQuI,eAKR,WACE,IAAMC,EAAMnI,KAAKoI,WACjB,GAAID,EAAIE,UAAW,QAASF,EAAIvI,OANlCD,EAAQyI,SA6XR,WACE,IAAME,EAAQ,CACZD,WAAW,EACXE,UAAW,KACXC,KAAM,IAAIC,KAER7I,EAAQ8I,EAAe1I,KAAMsI,GAC5BA,EAAMD,YAAWzI,OAAQ+I,GAC9B,MAAO,CACLN,UAAWC,EAAMD,UACjBO,MAAON,EAAMC,UACb3I,MAAOA,IAvYX,IAAMiJ,EAAgB,CAAC,SAAU,SAAU,QACrCC,EAAkB,CAAC,UAOzB,SAASF,EAAMnI,EAAM6H,GACdA,EAAMD,YACXC,EAAMC,UAAY9H,EAClB6H,EAAMD,WAAY,GAGpB,SAASK,EAAejI,EAAM6H,GAAO,IAEjCjI,EACEI,EADFJ,KAGAmI,EACEF,EADFE,KAGF,GAAIA,EAAK7B,IAAItG,GAAO,CAClB,IAAM0I,EAAWP,EAAK9H,IAAIL,GAE1B,OAAI0I,EAASC,SACJD,EAASnJ,WAEhBgJ,EAAMnI,EAAM6H,GAId,IAAMW,EAAO,CACXD,UAAU,GAEZR,EAAKtE,IAAI7D,EAAM4I,GAEf,IAAMC,EAWV,SAAmBzI,EAAM6H,GACvB,IAAKA,EAAMD,UAAW,OAEtB,GAAI5H,EAAK0I,uBAAwB,CAC/B,IAAMrB,EAAQrH,EAAKC,IAAI,eACvB,OAAOgI,EAAeZ,EAAMA,EAAMvH,OAAS,GAAI+H,GAGjD,GAAI7H,EAAK2I,mBAAqB3I,EAAK4I,oBAAsB5I,EAAK6I,mBAC5D,OAAO7I,EAAKJ,KAAKT,MAGnB,GAAIa,EAAK8I,gBACP,OAAO,KAGT,GAAI9I,EAAK+I,oBACP,OAAOC,EAAehJ,EAAMA,EAAKJ,KAAKqJ,OAAQpB,GAGhD,GAAI7H,EAAKkJ,8BAAgClJ,EAAKC,IAAI,OAAOkJ,qBAAsB,CAC7E,IAAMC,EAASpJ,EAAKC,IAAI,cAGpB6E,EAEAsE,EAHFxJ,KACEkF,KAGEuE,EAAWrJ,EAAKC,IAAI,gBAE1B,GAAImJ,EAAOE,gBAA2B,WAATxE,IAAsB9E,EAAK2D,MAAM4F,WAAWzE,IAASuE,EAASC,gBAAyC,QAAvBD,EAASzJ,KAAKkF,KACzH,OAAOkE,EAAehJ,EAAMA,EAAKJ,KAAK4J,MAAMP,OAAQpB,GAAO,GAI/D,GAAI7H,EAAKyJ,0BAA2B,CAClC,IAAMC,EAAazB,EAAejI,EAAKC,IAAI,QAAS4H,GACpD,IAAKA,EAAMD,UAAW,OAEtB,OACSK,EADLyB,EACoB1J,EAAKC,IAAI,cAETD,EAAKC,IAAI,aAFe4H,GAMlD,GAAI7H,EAAK2J,sBACP,OAAO1B,EAAejI,EAAKC,IAAI,cAAe4H,GAGhD,GAAI7H,EAAKmJ,uBAAyBnJ,EAAKyC,WAAWmH,iBAAiB,CACjE7E,OAAQ/E,EAAKJ,OACX,CACF,IAAMyJ,EAAWrJ,EAAKC,IAAI,YACpBmJ,EAASpJ,EAAKC,IAAI,UAExB,GAAImJ,EAAOS,aAAeR,EAASC,eAAgB,CACjD,IAAMnK,EAAQiK,EAAOxJ,KAAKT,MACpB+D,SAAc/D,EAEpB,GAAa,WAAT+D,GAA8B,WAATA,EACvB,OAAO/D,EAAMkK,EAASzJ,KAAKkF,OAKjC,GAAI9E,EAAK8J,yBAA0B,CACjC,IAAMC,EAAU/J,EAAK2D,MAAM4F,WAAWvJ,EAAKJ,KAAKkF,MAEhD,GAAIiF,GAAWA,EAAQC,mBAAmBlK,OAAS,EACjD,OAAOqI,EAAM4B,EAAQ/J,KAAM6H,GAG7B,GAAIkC,GAAW/J,EAAKJ,KAAKuB,MAAQ4I,EAAQ/J,KAAKJ,KAAKqK,IACjD,OAAO9B,EAAM4B,EAAQ/J,KAAM6H,GAG7B,GAAe,MAAXkC,OAAkB,EAASA,EAAQG,SACrC,OAAOH,EAAQ5K,MAEf,GAAuB,cAAnBa,EAAKJ,KAAKkF,KACZ,OAAOiF,EAAU5B,EAAM4B,EAAQ/J,KAAM6H,QAASK,EACzC,GAAuB,aAAnBlI,EAAKJ,KAAKkF,KACnB,OAAOiF,EAAU5B,EAAM4B,EAAQ/J,KAAM6H,GAASsC,IACzC,GAAuB,QAAnBnK,EAAKJ,KAAKkF,KACnB,OAAOiF,EAAU5B,EAAM4B,EAAQ/J,KAAM6H,GAASuC,IAGhD,IAAM7B,EAAWvI,EAAKqK,UAEtB,OAAI9B,IAAavI,EACRmI,EAAMnI,EAAM6H,GAEZI,EAAeM,EAAUV,GAKtC,GAAI7H,EAAKsK,kBAAkB,CACzBC,QAAQ,IACN,CACF,GAA2B,SAAvBvK,EAAKJ,KAAK4K,SACZ,OAGF,IAAMC,EAAWzK,EAAKC,IAAI,YAE1B,GAA2B,WAAvBD,EAAKJ,KAAK4K,WAA0BC,EAASC,cAAgBD,EAASE,WACxE,MAAO,WAGT,IAAMC,EAAM3C,EAAewC,EAAU5C,GACrC,IAAKA,EAAMD,UAAW,OAEtB,OAAQ5H,EAAKJ,KAAK4K,UAChB,IAAK,IACH,OAAQI,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,IACH,OAAQA,EAEV,IAAK,SACH,cAAcA,GAIpB,GAAI5K,EAAK6K,oBAAqB,CAC5B,IAD4B,EACtBC,EAAM,GACNC,EAAQ/K,EAAKC,IAAI,YAFK,IAIT8K,GAJS,IAI5B,2BAA0B,KAClBC,EADkB,QACDrD,WAEvB,IAAIqD,EAAUpD,UAGZ,OAAOO,EAAM6C,EAAU7C,MAAON,GAF9BiD,EAAI3D,KAAK6D,EAAU7L,QARK,8BAc5B,OAAO2L,EAGT,GAAI9K,EAAKiL,qBAAsB,CAC7B,IAD6B,EACvBnF,EAAM,GACNoF,EAAQlL,EAAKC,IAAI,cAFM,IAIViL,GAJU,IAI7B,2BAA0B,KAAfC,EAAe,QACxB,GAAIA,EAAKC,kBAAoBD,EAAKE,kBAChC,OAAOlD,EAAMgD,EAAMtD,GAGrB,IACIxH,EADY8K,EAAKlL,IAAI,OAGzB,GAAIkL,EAAKvL,KAAK0L,SAAU,CAGtB,KAFAjL,EAAMA,EAAIsH,YAEDC,UACP,OAAOO,EAAM9H,EAAI8H,MAAON,GAG1BxH,EAAMA,EAAIlB,WAEVkB,EADSA,EAAIiJ,eACPjJ,EAAIT,KAAKkF,KAETzE,EAAIT,KAAKT,MAGjB,IACIA,EADcgM,EAAKlL,IAAI,SACL0H,WAEtB,IAAKxI,EAAMyI,UACT,OAAOO,EAAMhJ,EAAMgJ,MAAON,GAG5B1I,EAAQA,EAAMA,MACd2G,EAAIzF,GAAOlB,GAlCgB,8BAqC7B,OAAO2G,EAGT,GAAI9F,EAAKuL,sBAAuB,CAC9B,IAAMC,EAAe3D,EAAMD,UACrB6D,EAAOxD,EAAejI,EAAKC,IAAI,QAAS4H,GACxC6D,EAAgB7D,EAAMD,UAC5BC,EAAMD,UAAY4D,EAClB,IAAMG,EAAQ1D,EAAejI,EAAKC,IAAI,SAAU4H,GAC1C+D,EAAiB/D,EAAMD,UAE7B,OAAQ5H,EAAKJ,KAAK4K,UAChB,IAAK,KAEH,GADA3C,EAAMD,UAAY8D,MAAoBD,GAAQG,IACzC/D,EAAMD,UAAW,OACtB,OAAO6D,GAAQE,EAEjB,IAAK,KAEH,GADA9D,EAAMD,UAAY8D,KAAmBD,GAAQG,IACxC/D,EAAMD,UAAW,OACtB,OAAO6D,GAAQE,GAIrB,GAAI3L,EAAK6L,qBAAsB,CAC7B,IAAMJ,EAAOxD,EAAejI,EAAKC,IAAI,QAAS4H,GAC9C,IAAKA,EAAMD,UAAW,OACtB,IAAM+D,EAAQ1D,EAAejI,EAAKC,IAAI,SAAU4H,GAChD,IAAKA,EAAMD,UAAW,OAEtB,OAAQ5H,EAAKJ,KAAK4K,UAChB,IAAK,IACH,OAAOiB,EAAOE,EAEhB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,KACH,OAAOG,KAAKC,IAAIN,EAAME,GAExB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,KACH,OAAOF,GAAQE,EAEjB,IAAK,KACH,OAAOF,GAAQE,EAEjB,IAAK,KACH,OAAOF,GAAQE,EAEjB,IAAK,KACH,OAAOF,GAAQE,EAEjB,IAAK,MACH,OAAOF,IAASE,EAElB,IAAK,MACH,OAAOF,IAASE,EAElB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,IACH,OAAOF,EAAOE,EAEhB,IAAK,KACH,OAAOF,GAAQE,EAEjB,IAAK,KACH,OAAOF,GAAQE,EAEjB,IAAK,MACH,OAAOF,IAASE,GAItB,GAAI3L,EAAK4J,mBAAoB,CAC3B,IACIoC,EACAC,EAFElH,EAAS/E,EAAKC,IAAI,UAQxB,GAJI8E,EAAOuE,iBAAmBtJ,EAAK2D,MAAM4F,WAAWxE,EAAOnF,KAAKkF,OAASsD,EAAc8D,QAAQnH,EAAOnF,KAAKkF,OAAS,IAClHmH,EAAOE,EAAOpH,EAAOnF,KAAKkF,OAGxBC,EAAOoE,qBAAsB,CAC/B,IAAMC,EAASrE,EAAO9E,IAAI,UACpBoJ,EAAWtE,EAAO9E,IAAI,YAO5B,GALImJ,EAAOE,gBAAkBD,EAASC,gBAAkBlB,EAAc8D,QAAQ9C,EAAOxJ,KAAKkF,OAAS,GAAKuD,EAAgB6D,QAAQ7C,EAASzJ,KAAKkF,MAAQ,IAEpJmH,GADAD,EAAUG,EAAO/C,EAAOxJ,KAAKkF,OACduE,EAASzJ,KAAKkF,OAG3BsE,EAAOS,aAAeR,EAASC,eAAgB,CACjD,IAAMpG,SAAckG,EAAOxJ,KAAKT,MAEnB,WAAT+D,GAA8B,WAATA,IAEvB+I,GADAD,EAAU5C,EAAOxJ,KAAKT,OACPkK,EAASzJ,KAAKkF,QAKnC,GAAImH,EAAM,CACR,IAAMG,EAAOpM,EAAKC,IAAI,aAAaoM,KAAI,SAAAzB,GAAG,OAAI3C,EAAe2C,EAAK/C,MAClE,IAAKA,EAAMD,UAAW,OACtB,OAAOqE,EAAKK,MAAMN,EAASI,IAI/BjE,EAAMnI,EAAM6H,GApUE0E,CAAUvM,EAAM6H,GAO5B,OALIA,EAAMD,YACRY,EAAKD,UAAW,EAChBC,EAAKrJ,MAAQsJ,GAGRA,EAgUX,SAASO,EAAehJ,EAAMiJ,EAAQpB,GAAoB,MAAb2E,EAAa,wDACpDC,EAAM,GACNC,EAAI,EACFrF,EAAQrH,EAAKC,IAAI,eAHiC,IAKrCgJ,GALqC,IAKxD,2BAA2B,KAAhB0D,EAAgB,QACzB,IAAK9E,EAAMD,UAAW,MACtB6E,GAAOD,EAAMG,EAAKxN,MAAMqN,IAAMG,EAAKxN,MAAMyN,OACzC,IAAMC,EAAOxF,EAAMqF,KACfG,IAAMJ,GAAOK,OAAO7E,EAAe4E,EAAMhF,MATS,8BAYxD,GAAKA,EAAMD,UACX,OAAO6E,K,oDC9XTzN,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ6N,cAgBR,WACE,IAAI1M,EAEJ,GAAId,KAAK4J,qBACP9I,EAAMd,KAAKK,KAAKyJ,aACX,KAAI9J,KAAKyN,eAAgBzN,KAAK0N,WAGnC,MAAM,IAAI5J,eAAe,QAFzBhD,EAAMd,KAAKK,KAAKS,IAKbd,KAAKK,KAAK0L,UACT5L,EAAE4J,aAAajJ,KAAMA,EAAMX,EAAEwN,cAAc7M,EAAIyE,OAGrD,OAAOzE,GA9BTnB,EAAQiO,YAiCR,WACE,IAAM3L,EAAOjC,KAAKU,IAAI,QAChBmN,EAAW5L,EAAK5B,KAEtB,GAAIsC,MAAMC,QAAQX,GAChB,MAAM,IAAIO,MAAM,iDAGlB,IAAKqL,EACH,MAAM,IAAIrL,MAAM,qCAGlB,GAAIP,EAAK6L,mBACP,OAAOD,EAGT,IAEI/M,EACAiN,EAHEC,EAAa,GACfC,EAAa,OAIbhM,EAAKoB,eACP0K,EAAU,OACVjN,EAAM,EACNkN,EAAWpG,KAAK3F,EAAK5B,QAErB4N,GAAc,UAEVjO,KAAKmL,cACPrK,EAAM,WACNkN,EAAWpG,KAAKzH,EAAEwF,gBAAgB1D,EAAK5B,SAEvCS,EAAM,aACNkN,EAAWpG,KAAKzH,EAAEiD,oBAAoBnB,EAAK5B,SAI/CL,KAAKK,KAAK4B,KAAO9B,EAAEuE,eAAesJ,GAClC,IAAM9K,EAAalD,KAAKU,IAAIuN,GAE5B,OADAhM,EAAKiM,MAAMhL,EAAY6K,EAAU7K,EAAW7C,KAAK0N,GAAW7K,EAAW7C,KAAM0N,EAASjN,GAC/Ed,KAAKK,MAxEdV,EAAQwO,wBA2ER,WACE,IAAKnO,KAAKoO,4BAA6B,OACvCpO,KAAK+F,6BA5EPpG,EAAQ0O,0BA+ER,WACE,IAAKrO,KAAKoO,8BAAgCpO,KAAKsO,yBAA2BtO,KAAKuO,wBAC7E,MAAMvO,KAAKwO,oBAAoB,kDAGjCC,EAAyBzO,OAnF3BL,EAAQoG,0BAsFR,WAIQ,6DAAJ,GAAI,IAHN2I,wBAGM,aAFNC,qBAEM,aADNC,mBACM,OADSD,EACT,EACN,IAAK3O,KAAKoO,4BACR,MAAMpO,KAAKwO,oBAAoB,+DAGjC,IAAMK,EAAcJ,EAAyBzO,KAAM4O,EAAaF,GAIhE,GAHA1O,KAAK4N,cACL5N,KAAKK,KAAKsD,KAAO,sBAEZiL,EAAa,CAChB,IAAME,EAAeD,EAAc,KAAO7O,KAAKkD,WAAWkB,MAAM2K,sBAAsB,gBAElFD,GACF9O,KAAKkD,WAAWkB,MAAMwD,KAAK,CACzBC,GAAIiH,EACJ7G,KAAM9H,EAAE6O,iBAAiB,MAI7BhP,KAAKU,IAAI,QAAQuO,iBAAiB,OAAQ9O,EAAEiD,oBAAoBjD,EAAEwE,eAAe3E,KAAKkP,IAAIC,UAAU,iBAAkB,CAAChP,EAAEiP,iBAAkBN,EAAe3O,EAAEmF,WAAWwJ,EAAavJ,MAAQpF,EAAEmF,WAAWuJ,OACzM7O,KAAKsC,YAAYnC,EAAEwE,eAAexE,EAAEkP,kBAAiB,EAAIC,EAAoBlN,SAASpC,MAAM,IAASA,KAAKK,KAAMF,EAAEmF,WAAW,SAAU,CAACwJ,EAAe3O,EAAEmF,WAAWwJ,EAAavJ,MAAQpF,EAAEiP,sBA5G/L,IAIgC7I,EAJ5BpG,EAQJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EARttBO,CAAwBd,EAAQ,KAEpCiJ,GAE4B/I,EAFiBF,EAAQ,OAEJE,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAEvF,SAASG,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EA0GlL,SAASgI,EAAyBc,GAAqD,IAA7CX,IAA6C,yDAAzBF,IAAyB,yDAC/Ec,EAAYD,EAAOrK,YAAW,SAAAuK,GAClC,OAAOA,EAAEtE,eAAiBsE,EAAErB,6BAA+BqB,EAAE/M,aAAe+M,EAAEC,gBAAgB,CAC5FC,QAAQ,OAGNC,EAAuE,iBAAzC,MAAbJ,OAAoB,EAASA,EAAUnP,KAAKmH,MAEnE,GAAIgI,EAAUE,kBACZ,MAAMH,EAAOf,oBAAoB,mDATkD,IA4GjFK,EA5GiF,EAkBjFgB,EAAoBN,GALtBO,EAbmF,EAanFA,UACAC,EAdmF,EAcnFA,eACAC,EAfmF,EAenFA,eACAC,EAhBmF,EAgBnFA,WACAC,EAjBmF,EAiBnFA,WAGF,GAAIN,GAAiBM,EAAW3P,OAAS,EAAG,CAC1C,IAAKmO,EACH,MAAMwB,EAAW,GAAG1B,oBAAoB,kDAG1C,IAAM2B,EAAgB,GACtBX,EAAU5K,SAAS,CACjByC,SADiB,SACR+I,GACHA,EAAMhC,6BACVgC,EAAM9I,QAGR+I,cANiB,SAMHD,GACZA,EAAM9I,QAGRgJ,eAViB,SAUFF,GACRA,EAAM1P,IAAI,UAAU6P,WACzBJ,EAAcvI,KAAKwI,MAIvB,IAAMI,EAAeC,EAAgBjB,GACrCW,EAAcO,SAAQ,SAAAC,GACpB,IAAMnL,EAASrF,EAAEmF,WAAWkL,GAC5BhL,EAAOhE,IAAMmP,EAAUtQ,KAAKmF,OAAOhE,IACnCmP,EAAUjQ,IAAI,UAAU4B,YAAYkD,MAIxC,GAAIuK,EAAexP,OAAS,EAAG,CAC7B,IAAMqQ,EAAmB5G,EAAWwF,EAAW,aAAa,kBAAMrP,EAAEmF,WAAW,gBAC/EyK,EAAeW,SAAQ,SAAAG,GACrB,IAAMC,EAAU3Q,EAAEmF,WAAWsL,GAC7BE,EAAQtP,IAAMqP,EAAexQ,KAAKmB,IAClCqP,EAAevO,YAAYwO,MAI/B,GAAId,EAAezP,OAAS,EAAG,CAC7B,IAAMwQ,EAAmB/G,EAAWwF,EAAW,aAAa,kBAAMrP,EAAE6Q,aAAa7Q,EAAEmF,WAAW,OAAQnF,EAAEmF,WAAW,cACnH0K,EAAeU,SAAQ,SAAAO,GACrB,IAAMC,EAAY/Q,EAAEmF,WAAWyL,GAC/BG,EAAU1P,IAAMyP,EAAY5Q,KAAKmB,IACjCyP,EAAY3O,YAAY4O,MAI5B,GAAIjB,EAAW1P,OAAS,EAAG,CACzB,IAAKmO,EACH,MAAMuB,EAAW,GAAGzB,oBAAoB,4CAG1C,IAAM2C,EAAiBlB,EAAWmB,QAAO,SAACC,EAAKC,GAAN,OAAoBD,EAAIE,OAAOC,EAAyBF,MAAa,IAC9GH,EAAeT,SAAQ,SAAAY,GACrB,IAAMxQ,EAAMwQ,EAAUjR,KAAK0L,SAAW,GAAKuF,EAAU5Q,IAAI,YAAYL,KAAKkF,KACpEkM,EAAeH,EAAUpO,WAAWwO,uBAAuB,CAC/DxF,KAAMoF,EAAUjR,OAEZsR,EAASL,EAAUpO,WAAWmH,iBAAiB,CACnD7E,OAAQ8L,EAAUjR,OAEdmQ,EAAeoB,EAAoBpC,EAAWiC,EAAc3Q,GAC5D+L,EAAO,GAMb,GAJIyE,EAAUjR,KAAK0L,UACjBc,EAAKjF,KAAK0J,EAAU5Q,IAAI,YAAYL,MAGlCoR,EAAc,CAChB,IAAM7R,EAAQ0R,EAAUpO,WAAW7C,KAAK+L,MACxCS,EAAKjF,KAAKhI,GAGZ,IAAMqH,EAAO9G,EAAEwE,eAAexE,EAAEmF,WAAWkL,GAAe3D,GAEtD8E,GACFL,EAAUpO,WAAW+L,iBAAiB,YAAa9O,EAAEiP,kBACrDkC,EAAUhP,YAAYnC,EAAEkP,iBAAiBpI,EAAM9G,EAAEmF,WAAW,UAC5DwK,EAAUlI,KAAK0J,EAAUpO,WAAWxC,IAAI,iBAC/B+Q,EACTH,EAAUpO,WAAWZ,YAAY2E,GAEjCqK,EAAUhP,YAAY2E,MAoB5B,OAbI6I,EAAUvP,OAAS,IAAMqO,KAC3BC,EAAcgD,EAAerC,EAAWI,IAEpChB,GAAegB,GAAiBkC,EAActC,MAChDM,EAAUY,SAAQ,SAAAqB,GAChB,IAAMC,EAAUD,EAAUE,QAAU9R,EAAE+R,cAAcrD,GAAe1O,EAAEmF,WAAWuJ,GAChFmD,EAAQxQ,IAAMuQ,EAAU1R,KAAKmB,IAC7BuQ,EAAUzP,YAAY0P,MAEnBpD,IAAaC,EAAc,QAI7BA,EAGT,SAAS2C,EAAyBF,GAChC,GAAIA,EAAUpO,WAAWwO,0BAAmE,MAAvCJ,EAAUpO,WAAW7C,KAAK4K,SAAkB,CAC/F,IAAMkH,EAAiBb,EAAUpO,WAC3BkP,EAAKD,EAAe9R,KAAK4K,SAASoH,MAAM,GAAI,GAC5CzS,EAAQuS,EAAe9R,KAAK+L,MAGlC,GAFA+F,EAAe9R,KAAK4K,SAAW,IAE3BqG,EAAUjR,KAAK0L,SAAU,CAC3B,IAAMuG,EAAMhB,EAAUlN,MAAMqB,8BAA8B,OAC1D0M,EAAezR,IAAI,QAAQ4B,YAAYnC,EAAEkP,iBAAiBiC,EAAUjR,KAAKwJ,OAAQ1J,EAAE2F,qBAAqB,IAAKwM,EAAKhB,EAAUjR,KAAKyJ,WAAW,IAC5IqI,EAAezR,IAAI,SAAS4B,YAAYnC,EAAEoS,iBAAiBH,EAAIjS,EAAEkP,iBAAiBiC,EAAUjR,KAAKwJ,OAAQ1J,EAAEmF,WAAWgN,EAAI/M,OAAO,GAAO3F,SAExIuS,EAAezR,IAAI,QAAQ4B,YAAYnC,EAAEkP,iBAAiBiC,EAAUjR,KAAKwJ,OAAQyH,EAAUjR,KAAKyJ,WAChGqI,EAAezR,IAAI,SAAS4B,YAAYnC,EAAEoS,iBAAiBH,EAAIjS,EAAEkP,iBAAiBiC,EAAUjR,KAAKwJ,OAAQ1J,EAAEmF,WAAWgM,EAAUjR,KAAKyJ,SAASvE,OAAQ3F,IAGxJ,MAAO,CAACuS,EAAezR,IAAI,QAASyR,EAAezR,IAAI,SAASA,IAAI,SAC/D,GAAI4Q,EAAUpO,WAAWsP,qBAAsB,CACpD,IAAMC,EAAanB,EAAUpO,WACvBoP,EAAMhB,EAAUlN,MAAMqB,8BAA8B,OACpDiN,EAAcpB,EAAUjR,KAAK0L,SAAWuF,EAAUlN,MAAMqB,8BAA8B,QAAU,KAChGkN,EAAQ,CAACxS,EAAE2F,qBAAqB,IAAKwM,EAAKnS,EAAEkP,iBAAiBiC,EAAUjR,KAAKwJ,OAAQ6I,EAAcvS,EAAE2F,qBAAqB,IAAK4M,EAAapB,EAAUjR,KAAKyJ,UAAYwH,EAAUjR,KAAKyJ,SAAUwH,EAAUjR,KAAK0L,WAAY5L,EAAE2F,qBAAqB,IAAK3F,EAAEkP,iBAAiBiC,EAAUjR,KAAKwJ,OAAQ6I,EAAcvS,EAAEmF,WAAWoN,EAAYnN,MAAQ+L,EAAUjR,KAAKyJ,SAAUwH,EAAUjR,KAAK0L,UAAW5L,EAAEoS,iBAAiB,IAAKpS,EAAEmF,WAAWgN,EAAI/M,MAAOpF,EAAEyS,eAAe,MASzc,OAPKtB,EAAUpO,WAAW7C,KAAK2K,QAC7B2H,EAAM/K,KAAKzH,EAAEmF,WAAWgN,EAAI/M,OAG9BkN,EAAWnQ,YAAYnC,EAAE0S,mBAAmBF,IAGrC,CAFMF,EAAW/R,IAAI,uBACd+R,EAAW/R,IAAI,uBAI/B,MAAO,CAAC4Q,GAGV,SAASQ,EAActC,GACrB,OAAOA,EAAUsD,mBAAqBtD,EAAUtM,WAAWA,WAAW7C,KAAK0S,WAG7E,SAASlB,EAAerC,EAAWI,GACjC,OAAO5F,EAAWwF,EAAW,QAAQ,SAAAX,GACnC,IAAKe,IAAkBkC,EAActC,GAAY,OAAOrP,EAAEiP,iBAC1D,IAAM4D,EAAS,IAAIC,QACnBzD,EAAU5K,SAAS,CACjByC,SADiB,SACR+I,GACHA,EAAMhC,6BACVgC,EAAM9I,QAGR+I,cANiB,SAMHD,GACZA,EAAM9I,QAGRgJ,eAViB,SAUFF,GACRA,EAAM1P,IAAI,UAAU6P,YACrByC,EAAOrM,IAAIyJ,EAAM/P,QACrB2S,EAAOE,IAAI9C,EAAM/P,MACjB+P,EAAMvQ,oBAAoB,CAACuQ,EAAM/P,KAAMF,EAAE2F,qBAAqB,IAAK3F,EAAEmF,WAAWuJ,GAAc1O,EAAEmF,WAAW,mBAOnH,SAASmL,EAAgBjB,GACvB,OAAOxF,EAAWwF,EAAW,aAAa,WACxC,IAAM2D,EAAc3D,EAAUpL,MAAM2K,sBAAsB,QAC1D,OAAO5O,EAAEsE,wBAAwB,CAACtE,EAAEiT,YAAYD,IAAehT,EAAEwE,eAAexE,EAAEkT,QAAS,CAAClT,EAAEmT,cAAcnT,EAAEmF,WAAW6N,EAAY5N,aAIzI,SAASqM,EAAoBpC,EAAWiC,EAAc8B,GAEpD,OAAOvJ,EAAWwF,EAAD,oBADNiC,EAAe,MAAQ,MACjB,YAA+B8B,GAAY,KAAM,WAChE,IACIC,EADEC,EAAW,GAGjB,GAAIF,EACFC,EAASrT,EAAEkP,iBAAiBlP,EAAEkT,QAASlT,EAAEmF,WAAWiO,QAC/C,CACL,IAAMG,EAASlE,EAAUpL,MAAM2K,sBAAsB,QACrD0E,EAASE,QAAQD,GACjBF,EAASrT,EAAEkP,iBAAiBlP,EAAEkT,QAASlT,EAAEmF,WAAWoO,EAAOnO,OAAO,GAGpE,GAAIkM,EAAc,CAChB,IAAMmC,EAAapE,EAAUpL,MAAM2K,sBAAsB,SACzD0E,EAAS7L,KAAKgM,GACdJ,EAASrT,EAAE2F,qBAAqB,IAAK0N,EAAQrT,EAAEmF,WAAWsO,EAAWrO,OAGvE,OAAOpF,EAAEsE,wBAAwBgP,EAAUD,MAI/C,SAASxJ,EAAWwF,EAAW1O,EAAKmH,GAClC,IAAM4L,EAAW,WAAa/S,EAC1BgT,EAAOtE,EAAUnK,QAAQwO,GAE7B,IAAKC,EAAM,CACT,IAAMjM,EAAK2H,EAAUpL,MAAM2K,sBAAsBjO,GACjDgT,EAAOjM,EAAGtC,KACViK,EAAU3J,QAAQgO,EAAUC,GAC5BtE,EAAUpL,MAAMwD,KAAK,CACnBC,GAAIA,EACJI,KAAMA,EAAK6L,KAIf,OAAOA,EAGT,SAASjE,EAAoBN,GAC3B,IAAMO,EAAY,GACZC,EAAiB,GACjBC,EAAiB,GACjBC,EAAa,GACbC,EAAa,GAqDnB,OApDAX,EAAO3K,SAAS,CACdyL,cADc,SACAD,GACZA,EAAM9I,QAGRD,SALc,SAKL+I,GACHA,EAAMhC,6BACVgC,EAAM9I,QAGRyM,eAVc,SAUC3D,GACbN,EAAUlI,KAAKwI,IAGjB4D,cAdc,SAcA5D,GACY,SAApBA,EAAM/P,KAAKkF,OAEV6K,EAAMlN,WAAW+Q,sBAAsB,CAC1CpK,OAAQuG,EAAM/P,QACT+P,EAAMlN,WAAWgR,oBAAoB,CAC1C3O,KAAM6K,EAAM/P,SAKdyP,EAAUlI,KAAKwI,IAGjBE,eA5Bc,SA4BCF,GACTA,EAAM1P,IAAI,UAAU6P,WAAWL,EAAWtI,KAAKwI,IAGrD+D,iBAhCc,SAgCG/D,GACXA,EAAM1P,IAAI,UAAU6P,WAAWN,EAAWrI,KAAKwI,IAGrDgE,qBApCc,SAoCOhE,GACK,cAApBA,EAAM/P,KAAKkF,MACfwK,EAAenI,KAAKwI,IAGtBiE,aAzCc,SAyCDjE,GACNA,EAAM1P,IAAI,QAAQqJ,aAAa,CAClCxE,KAAM,SAEH6K,EAAM1P,IAAI,YAAYqJ,aAAa,CACtCxE,KAAM,YAERyK,EAAepI,KAAKwI,MAIjB,CACLN,YACAC,iBACAC,iBACAC,aACAC,gB,8CCvaJzQ,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ2U,eA2BR,SAAwBC,EAASC,GAC/B,OAAOrU,EAAEmU,eAAetU,KAAKK,KAAMkU,EAASC,IA3B9C7U,EAAQgH,IAAMA,EACdhH,EAAQ8U,SAuCR,WACE,OAAOzU,KAAKoE,MAAMqQ,SAASzU,KAAKK,OAvClCV,EAAQ+U,KA6CR,SAAc5T,GACZ,OAAQd,KAAK2G,IAAI7F,IA7CnBnB,EAAQgV,OAgDR,SAAgB7T,EAAKlB,GACnB,OAAOI,KAAKK,KAAKS,KAASlB,GAhD5BD,EAAQmD,WAmDR,SAAoBa,GAClB,OAAOxD,EAAEyU,OAAO5U,KAAK2D,KAAMA,IAnD7BhE,EAAQqD,uCAsDR,WACE,OAAqB,SAAbhD,KAAKc,KAA+B,SAAbd,KAAKc,MAAmBd,KAAKkD,WAAW2R,SAtDzElV,EAAQsD,qCAyDR,SAA8C7B,GAC5C,GAAiB,SAAbpB,KAAKc,MAAmBd,KAAKkD,WAAWkL,4BAC1C,OAAO,EAGT,GAAIpO,KAAK+C,eACP,OAAO5C,EAAE2N,iBAAiB1M,GACrB,GAAIpB,KAAK8N,mBACd,OAAO3N,EAAE4C,aAAa3B,GAGxB,OAAO,GAnETzB,EAAQmV,mBAsER,SAA4BC,GAC1B,IAAItU,EAAOT,KACPgV,GAAQ,EAEZ,EAAG,CACD,IAAMnU,EAAYJ,EAAKI,UAEvB,GAAIJ,EAAK0K,eAAiB6J,EACxB,QAASD,EAKX,GAFAC,GAAQ,EAEJrS,MAAMC,QAAQ/B,IAAcJ,EAAKK,MAAQD,EAAUN,OAAS,EAC9D,OAAO,SAEDE,EAAOA,EAAKyC,cAAgBzC,EAAKiC,aAE3C,OAAO,GAvFT/C,EAAQsV,mBA0FR,WACE,OAAIjV,KAAKkD,WAAWgS,uBAAwB/U,EAAE2N,iBAAiB9N,KAAKa,YAG3DV,EAAEgV,wBAAwBC,SAASpV,KAAKc,MA7FnDnB,EAAQ0V,iBAiGR,SAA0BC,EAAcC,GACtC,IAAKvV,KAAKuK,yBAA0B,CAClC,IAAKvK,KAAK4J,sBAAwB5J,KAAKwV,gCAAkCxV,KAAKK,KAAK0L,SAAW5L,EAAEiJ,gBAAgBpJ,KAAKK,KAAKyJ,SAAU,CAClIlK,MAAO2V,IACJvV,KAAKK,KAAKyJ,SAASvE,OAASgQ,GAAa,CAC5C,IAAM1L,EAAS7J,KAAKU,IAAI,UACxB,OAAOmJ,EAAOU,0BAA4BV,EAAOwL,iBAAiBC,EAAc,KAGlF,OAAO,EAGT,IAAM9K,EAAUxK,KAAKoE,MAAM4F,WAAWhK,KAAKK,KAAKkF,MAChD,IAAKiF,GAA4B,WAAjBA,EAAQhD,KAAmB,OAAO,EAClD,IAAM/G,EAAO+J,EAAQ/J,KACfE,EAASF,EAAKyC,WACpB,IAAKvC,EAAO8U,sBAAuB,OAAO,EAE1C,GAAI9U,EAAON,KAAKqV,OAAO9V,QAAU0V,EAG/B,OAAO,EAFP,IAAKC,EAAY,OAAO,EAK1B,GAAI9U,EAAKkV,4BAA6C,YAAfJ,EACrC,OAAO,EAGT,GAAI9U,EAAKmV,8BAA+C,MAAfL,EACvC,OAAO,EAGT,GAAI9U,EAAKoV,qBAAuB1V,EAAE4J,aAAatJ,EAAKJ,KAAKyV,SAAU,CACjEvQ,KAAMgQ,IAEN,OAAO,EAGT,OAAO,GAtIT5V,EAAQoW,UAyIR,WACE,IAAM1V,EAAOL,KAAKK,KAElB,GAAIA,EAAKqK,IAAK,CACZ,IAAM3I,EAAO/B,KAAKkP,IAAI8G,UACtB,GAAIjU,EAAM,OAAOA,EAAKsQ,MAAMhS,EAAKuB,MAAOvB,EAAKqK,KAG/C,MAAO,IAhJT/K,EAAQsW,wBAmJR,SAAiCC,GAC/B,MAAwD,UAAjDlW,KAAKmW,gCAAgCD,IAnJ9CvW,EAAQwW,gCA4MR,SAAyCD,GACvC,IAAME,EAAa,CACjBpW,KAAMqW,EAAiBrW,MACvBkW,OAAQG,EAAiBH,IAG3B,GAAIE,EAAWF,OAAO7V,OAAS+V,EAAWpW,KAAKK,KAC7C,OAAOL,KAAKsW,kDAAkDF,EAAWF,QAG3E,IAMIK,EANExV,EAAQ,CACZmV,OAAQA,EAAOM,cACfxW,KAAMA,KAAKwW,eAEb,GAAIzV,EAAMmV,OAAOvJ,QAAQ3M,OAAS,EAAG,MAAO,QAC5C,GAAIe,EAAMf,KAAK2M,QAAQuJ,IAAW,EAAG,MAAO,SAE5C,IAAMO,EAAc,CAClBP,OAAQ,EACRlW,KAAM,GAGR,MAAQuW,GAAcE,EAAYzW,KAAOe,EAAMf,KAAKO,QAAQ,CAC1D,IAAME,EAAOM,EAAMf,KAAKyW,EAAYzW,MACpCyW,EAAYP,OAASnV,EAAMmV,OAAOvJ,QAAQlM,GAEtCgW,EAAYP,QAAU,EACxBK,EAAa9V,EAEbgW,EAAYzW,OAIhB,IAAKuW,EACH,MAAM,IAAI/T,MAAM,6FAGlB,GAAIkU,EAA2B3V,EAAMf,KAAMyW,EAAYzW,KAAO,IAAM0W,EAA2B3V,EAAMmV,OAAQO,EAAYP,OAAS,GAChI,MAAO,UAGT,IAAMS,EAAa,CACjB3W,KAAMe,EAAMf,KAAKyW,EAAYzW,KAAO,GACpCkW,OAAQnV,EAAMmV,OAAOO,EAAYP,OAAS,IAG5C,GAAIS,EAAWT,OAAOnI,SAAW4I,EAAW3W,KAAK+N,SAAW4I,EAAWT,OAAOrV,YAAc8V,EAAW3W,KAAKa,UAC1G,OAAO8V,EAAWT,OAAOpV,IAAM6V,EAAW3W,KAAKc,IAAM,SAAW,QAGlE,IAAM6G,EAAOxH,EAAEyW,aAAaL,EAAW5S,MACjCkT,EAAc,CAClB7W,KAAM2H,EAAKgF,QAAQgK,EAAW3W,KAAK8W,WACnCZ,OAAQvO,EAAKgF,QAAQgK,EAAWT,OAAOY,YAEzC,OAAOD,EAAYX,OAASW,EAAY7W,KAAO,SAAW,SAlQ5DL,EAAQ2W,kDAuQR,SAA2DJ,GACzD,IAAKA,EAAO3H,yBAA2B2H,EAAOhT,WAAW6T,sBACvD,MAAO,UAGT,IAAMvM,EAAU0L,EAAO9R,MAAM4F,WAAWkM,EAAO7V,KAAKwH,GAAGtC,MACvD,IAAKiF,EAAQwM,WAAY,MAAO,SAChC,IACIC,EAR6D,EAO3DC,EAAiB1M,EAAQ0M,eAPkC,IAU9CA,GAV8C,IAUjE,2BAAmC,KAAxBzW,EAAwB,QAEjC,MAD0BA,EAAK0W,MAAK,SAAA1W,GAAI,OAAIA,EAAKJ,OAAS6V,EAAO7V,QACjE,CAEA,GAAiB,WAAbI,EAAKK,MAAqBL,EAAKyC,WAAWmH,mBAC5C,MAAO,UAGT,IAAI+M,EAA2BzQ,IAAIlG,EAAKJ,MAAxC,CACA+W,EAA2BlE,IAAIzS,EAAKJ,MAEpC,IAAMgX,EAASrX,KAAKmW,gCAAgC1V,GAIpD,GAFA2W,EAA2BxW,OAAOH,EAAKJ,MAEnC4W,GAAaA,IAAcI,EAC7B,MAAO,UAEPJ,EAAYI,KA5BiD,8BAgCjE,OAAOJ,GAtSTtX,EAAQmL,QAySR,SAAiBwM,EAAWtO,GAC1B,OAAOhJ,KAAKuX,SAASD,EAAWtO,IAAahJ,MAzS/CL,EAAQ4X,SA4SR,SAAkBD,EAAWtO,GAC3B,GAAIA,GAAYA,EAAS2D,QAAQ3M,OAAS,EAAG,OAI7C,IAHAgJ,EAAWA,GAAY,IACdpB,KAAK5H,MAEVA,KAAKwX,wBACP,GAAIxX,KAAKU,IAAI,MAAMqJ,eACjB,OAAO/J,KAAKU,IAAI,QAAQoK,QAAQwM,EAAWtO,QAExC,GAAIhJ,KAAKuK,yBAA0B,CACxC,IAAMC,EAAUxK,KAAKoE,MAAM4F,WAAWhK,KAAKK,KAAKkF,MAChD,IAAKiF,EAAS,OACd,IAAKA,EAAQiN,SAAU,OACvB,GAAqB,WAAjBjN,EAAQhD,KAAmB,OAE/B,GAAIgD,EAAQ/J,OAAST,KAAM,CACzB,IAAM0X,EAAMlN,EAAQ/J,KAAKqK,QAAQwM,EAAWtO,GAC5C,GAAIhJ,KAAKmX,MAAK,SAAAxW,GAAM,OAAIA,EAAON,OAASqX,EAAIrX,QAAO,OACnD,OAAOqX,OAEJ,IAAI1X,KAAK2X,uBACd,OAAO3X,KAAKU,IAAI,cAAcoK,QAAQwM,EAAWtO,GAC5C,GAAIsO,GAAatX,KAAK4J,qBAAsB,CACjD,IAAMgO,EAAY5X,KAAKwN,gBACvB,IAAKrN,EAAEmK,UAAUsN,GAAY,OAC7B,IAAMC,EAAaD,EAAUhY,MACvBsW,EAASlW,KAAKU,IAAI,UAAUoK,QAAQwM,EAAWtO,GAErD,GAAIkN,EAAOxK,qBAAsB,CAC/B,IAD+B,EACzBC,EAAQuK,EAAOxV,IAAI,cADM,IAGZiL,GAHY,IAG/B,2BAA0B,KAAfC,EAAe,QACxB,GAAKA,EAAK6B,aAAV,CACA,IAAM3M,EAAM8K,EAAKlL,IAAI,OACjBoX,EAAQlM,EAAK8I,KAAK,aAAe5T,EAAIiJ,aAAa,CACpDxE,KAAMsS,IAKR,GAHAC,EAAQA,GAAShX,EAAIwJ,UAAU,CAC7B1K,MAAOiY,IAEE,OAAOjM,EAAKlL,IAAI,SAASoK,QAAQwM,EAAWtO,KAZ1B,oCAc1B,GAAIkN,EAAO5K,sBAAwByM,OAAOF,GAAa,CAC5D,IACMzK,EADQ8I,EAAOxV,IAAI,YACNmX,GACnB,GAAIzK,EAAM,OAAOA,EAAKtC,QAAQwM,EAAWtO,OAxV/CrJ,EAAQqY,qBA6VR,WACE,GAAIhY,KAAK+J,eAAgB,CACvB,IAAMS,EAAUxK,KAAKoE,MAAM4F,WAAWhK,KAAKK,KAAKkF,MAChD,QAAKiF,GACEA,EAAQiN,SAGjB,GAAIzX,KAAKsK,YACP,OAAItK,KAAKiY,qBAILjY,KAAKwJ,qBACAxJ,KAAKU,IAAI,eAAewX,OAAM,SAAAhW,GAAU,OAAIA,EAAW8V,2BAMlE,GAAIhY,KAAK+K,oBACP,MAA2B,SAAvB/K,KAAKK,KAAK4K,UAIPjL,KAAKU,IAAI,YAAYsX,uBAG9B,GAAIhY,KAAKsM,qBACP,OAAOtM,KAAKU,IAAI,QAAQsX,wBAA0BhY,KAAKU,IAAI,SAASsX,uBAGtE,OAAO,GA3XTrY,EAAQwY,eA8XR,WAqBE,SApBcnY,KAAK0C,YAAc1C,KAAOA,KAAKkD,YAClBiU,MAAK,SAAA1W,GAC9B,GAAIA,EAAKiC,UAAU,CACjB0V,WAAY,WACV,OAAO,EACX,GAAI3X,EAAK2K,UAAW,OAAO,EAC3B,IAAK3K,EAAKiC,cAAgBjC,EAAK0K,aAAc,OAAO,EAEpD,GAAI1K,EAAK2N,8BAAgC3N,EAAKC,IAAI,QAAQoN,mBACxD,OAAO,EAGT,IAXsC,EAWhC7L,EAAOxB,EAAK0K,aAAe1K,EAAKJ,KAAK4B,KAAOxB,EAAKJ,KAXjB,IAad4B,EAAKoW,YAbS,IAatC,2BAAyC,CACvC,GAA8B,eADS,QACzBzY,MAAMA,MAClB,OAAO,GAf2B,mCA/X1CD,EAAQ6E,QAAK,EAEb,IAAIrE,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAQlL,SAASE,EAAI7F,GACX,IAAMoI,EAAMlJ,KAAKK,MAAQL,KAAKK,KAAKS,GAEnC,OAAIoI,GAAOvG,MAAMC,QAAQsG,KACdA,EAAI3I,SAEJ2I,EAQb,IAAM1E,EAAKmC,EAsHX,SAAS0P,EAAiB5V,GACxB,OAAQA,EAAK2D,MAAME,qBAAuB7D,EAAK2D,MAAMkU,oBAAoB7X,KAG3E,SAAS8X,EAAqB5U,EAAM7C,GAClC,OAAQ6C,GACN,IAAK,oBACH,MAAe,UAAR7C,EAET,IAAK,wBACL,IAAK,cACH,MAAe,eAARA,GAAgC,cAARA,EAEjC,IAAK,iBACL,IAAK,mBACL,IAAK,iBACL,IAAK,iBACH,MAAe,SAARA,EAET,IAAK,eACH,MAAe,SAARA,GAA0B,WAARA,EAE3B,IAAK,kBACH,MAAe,UAARA,EAET,IAAK,eACH,MAAe,YAARA,EAET,IAAK,oBACH,MAAe,UAARA,EAET,IAAK,2BACH,MAAe,aAARA,EAET,IAAK,yBACH,MAAe,cAARA,EAET,QACE,OAAO,GAIb,SAAS4V,EAA2B3V,EAAOyX,GACzC,IAAK,IAAIrL,EAAI,EAAGA,EAAIqL,EAAUrL,IAAK,CACjC,IAAM1M,EAAOM,EAAMoM,GAEnB,GAAIoL,EAAqB9X,EAAKE,OAAOgD,KAAMlD,EAAKqW,WAC9C,OAAO,EAIX,OAAO,EAxKTnX,EAAQ6E,GAAKA,EAqOb,IAAM4S,EAA6B,IAAInE,S,8CCtRvCxT,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQsH,KA2BR,SAAcnG,GACZ,IAAM2X,EAAOzY,KAAKyY,KAGlB,GAFAzY,KAAKiE,MAAMnD,GAEPd,KAAKK,MACHL,KAAK0Y,MAAMD,EAAK3X,IAAO,OAAO,EAGpC,GAAId,KAAKK,KACP,OAAOL,KAAK0Y,MAAMD,EAAKzY,KAAKK,KAAKsD,OAAS8U,EAAKzY,KAAKK,KAAKsD,MAAM7C,IAGjE,OAAO,GAtCTnB,EAAQ+Y,MAyCR,SAAeC,GACb,IAAKA,EAAK,OAAO,EADC,UAGDA,GAHC,IAGlB,2BAAsB,KAAXC,EAAW,QACpB,GAAKA,EAAL,CACA,IAAMvY,EAAOL,KAAKK,KAClB,IAAKA,EAAM,OAAO,EAClB,IAAMqX,EAAMkB,EAAG3R,KAAKjH,KAAKsI,MAAOtI,KAAMA,KAAKsI,OAE3C,GAAIoP,GAAsB,kBAARA,GAAwC,oBAAbA,EAAImB,KAC/C,MAAM,IAAIrW,MAAM,gNAGlB,GAAIkV,EACF,MAAM,IAAIlV,MAAJ,sDAAyDoW,IAGjE,GAAI5Y,KAAKK,OAASA,EAAM,OAAO,EAC/B,GAAIL,KAAK8Y,eAAiB,EAAG,OAAO,IAlBpB,8BAqBlB,OAAO,GA7DTnZ,EAAQoZ,cAAgBpZ,EAAQqZ,aAgEhC,WACE,IAAIC,EAEEC,EAAyD,OAA7CD,EAAsBjZ,KAAKyY,KAAKS,UAAoBD,EAAsBjZ,KAAKyY,KAAKU,UACtG,OAAOD,GAAYA,EAASvM,QAAQ3M,KAAKK,KAAKsD,OAAS,GAnEzDhE,EAAQyZ,MAsER,WACE,IAAKpZ,KAAKK,KACR,OAAO,EAGT,GAAIL,KAAKgZ,eACP,OAAO,EAGT,GAAIhZ,KAAKyY,KAAKY,YAAcrZ,KAAKyY,KAAKY,WAAWrZ,MAC/C,OAAO,EAGT,GAAIA,KAAKqZ,YAAcrZ,KAAKiH,KAAK,UAAYjH,KAAKqZ,WAEhD,OADArZ,KAAKiE,MAAM,WACJjE,KAAKsZ,WAQd,OALAtZ,KAAKiE,MAAM,qBAEX9B,EAAOC,QAAQ/B,KAAKL,KAAKK,KAAML,KAAKyY,KAAMzY,KAAKoE,MAAOpE,KAAKsI,MAAOtI,KAAMA,KAAKuZ,UAE7EvZ,KAAKiH,KAAK,QACHjH,KAAKsZ,YA5Fd3Z,EAAQ2H,KA+FR,WACEtH,KAAKqZ,YAAa,GA/FpB1Z,EAAQ6Z,QAkGR,SAAiB1Y,GACM,MAAjBd,KAAKuZ,WACPvZ,KAAKuZ,SAAW,IAGlBvZ,KAAKuZ,SAASzY,IAAO,GAtGvBnB,EAAQ8Z,KAyGR,WACEzZ,KAAK8Y,gBAAkBrW,EAAQiX,YAAcjX,EAAQkX,aAzGvDha,EAAQiE,SA4GR,WACE,GAAI5D,KAAKyY,MAAQzY,KAAKyY,KAAKmB,QAAS,OACpC,IAEI1D,EAFAzV,EAAOT,KAAKkD,WACC,QAAblD,KAAKc,KAAiBL,EAAKiN,aAAYjN,EAAOA,EAAKyC,YAGvD,KAAOzC,IAASyV,GAAQ,CACtB,GAAIzV,EAAKgY,MAAQhY,EAAKgY,KAAKmB,QAAS,OACpC1D,EAASzV,EAAK2D,MACd3D,EAAOA,EAAKyC,WAGdlD,KAAKoE,MAAQpE,KAAK6Z,SAAS3D,GACvBlW,KAAKoE,OAAOpE,KAAKoE,MAAM6D,QAxH7BtI,EAAQma,WA2HR,SAAoBrN,GACG,MAAjBzM,KAAKuZ,WACPvZ,KAAKuZ,SAAW,IAGlBvZ,KAAK8Y,eAAiB,EAElBrM,IACFzM,KAAKyM,QAAUA,EACfzM,KAAKsI,MAAQmE,EAAQnE,MACrBtI,KAAKyY,KAAOhM,EAAQgM,MAItB,OADAzY,KAAK4D,WACE5D,MAxITL,EAAQM,OA2IR,WACE,GAAID,KAAKuC,QAAS,OAElBvC,KAAK+Z,gBAEL/Z,KAAKga,cAELha,KAAKia,cAjJPta,EAAQoa,cAoJR,WACM/Z,KAAKkD,aACPlD,KAAKW,OAASX,KAAKkD,WAAW7C,OArJlCV,EAAQsa,WAyJR,WACE,IAAKja,KAAKa,UAAW,OACrB,GAAIb,KAAKK,OAASL,KAAKa,UAAUb,KAAKc,KAAM,OAE5C,GAAI6B,MAAMC,QAAQ5C,KAAKa,YACrB,IAAK,IAAIsM,EAAI,EAAGA,EAAInN,KAAKa,UAAUN,OAAQ4M,IACzC,GAAInN,KAAKa,UAAUsM,KAAOnN,KAAKK,KAC7B,OAAOL,KAAKka,OAAO/M,QAIvB,cAAkB1N,OAAOkI,KAAK3H,KAAKa,WAAnC,eAA+C,CAA1C,IAAMC,EAAG,KACZ,GAAId,KAAKa,UAAUC,KAASd,KAAKK,KAC/B,OAAOL,KAAKka,OAAOpZ,GAKzBd,KAAKc,IAAM,MA1KbnB,EAAQqa,YA6KR,WACE,IAAKha,KAAKW,SAAWX,KAAK+D,OAAQ,OAClC,IAAMoW,EAAena,KAAKW,OAAOX,KAAK+N,SACtC,GAAI/N,KAAKa,YAAcsZ,EAAc,OACrCna,KAAKa,UAAYsZ,GAAgB,MAhLnCxa,EAAQya,eAmLR,WACkB,MAAZpa,KAAKc,KAAgBd,KAAKa,WAAab,KAAKa,UAAUb,KAAKc,OAASd,KAAKK,MAC3EL,KAAKqa,gBApLT1a,EAAQ2a,WAwLR,WACEta,KAAKua,SAASC,MAEVxa,KAAKua,SAASha,OAAS,EACzBP,KAAK8Z,WAAW9Z,KAAKua,SAASva,KAAKua,SAASha,OAAS,IAErDP,KAAK8Z,gBAAWnR,IA7LpBhJ,EAAQ8a,YAiMR,SAAqBhO,GACnBzM,KAAKua,SAAS3S,KAAK6E,GACnBzM,KAAK8Z,WAAWrN,IAlMlB9M,EAAQuO,MAqMR,SAAehL,EAAYrC,EAAWkN,EAASjN,GAC7Cd,KAAK+N,QAAUA,EACf/N,KAAKa,UAAYA,EACjBb,KAAKkD,WAAaA,GAAclD,KAAKkD,WACrClD,KAAKka,OAAOpZ,IAxMdnB,EAAQua,OA2MR,SAAgBpZ,GACd,IAAI4Z,EAEJ1a,KAAKc,IAAMA,EACXd,KAAKK,KAAOL,KAAKa,UAAUb,KAAKc,KAChCd,KAAK2D,KAAmC,OAA3B+W,EAAa1a,KAAKK,WAAgB,EAASqa,EAAW/W,MA/MrEhE,EAAQsB,QAkNR,WAAqC,IAApB0Z,EAAoB,uDAAN3a,KAC7B,GAAI2a,EAAYpY,QAAS,OACzB,IAFmC,EAE7BgY,EAAWva,KAAKua,SAFa,IAIbA,GAJa,IAInC,2BAAgC,KAArB9N,EAAqB,QAC9BA,EAAQmO,WAAWD,IALc,gCAjNrChb,EAAQkb,kBA0NR,WACE,IAAIpa,EAAOT,KACPua,EAAWva,KAAKua,SAEpB,MAAQA,EAASha,SACfE,EAAOA,EAAKyC,aAEZqX,EAAW9Z,EAAK8Z,SAGlB,OAAOA,GAlOT,IAIgChU,EAJ5BpE,GAI4BoE,EAJIF,EAAQ,MAISE,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAFnF9D,EAAU4D,EAAQ,K,8CC1BtB5G,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQuB,OAiBR,WACE,IAAI4Z,EAEJ9a,KAAK+a,mBAEL/a,KAAKC,UAE6B,OAA3B6a,EAAa9a,KAAKyY,WAAgB,EAASqC,EAAWlB,UAC3D5Z,KAAKgb,mBAGP,GAAIhb,KAAKib,oBAGP,YAFAjb,KAAKqa,eAKPra,KAAKkb,4BAELlb,KAAKmb,UAELnb,KAAKqa,gBArCP1a,EAAQqb,iBAwCR,WAA4B,WACpBvT,EAAWzH,KAAK0H,wBACtBjI,OAAOkI,KAAKF,GAAUiJ,SAAQ,SAAAnL,GAAI,OAAI,EAAKnB,MAAMgX,cAAc7V,OAzCjE5F,EAAQsb,kBA4CR,WAA6B,UACVI,EAAcC,OADJ,IAC3B,2BAAsC,CACpC,IAAI1C,EADgC,SAC7B5Y,KAAMA,KAAKkD,YAAa,OAAO,GAFb,gCA3C7BvD,EAAQwb,QAiDR,WACMxY,MAAMC,QAAQ5C,KAAKa,YACrBb,KAAKa,UAAU0a,OAAOvb,KAAKc,IAAK,GAChCd,KAAKwb,kBAAkBxb,KAAKc,KAAM,IAElCd,KAAK0D,aAAa,OArDtB/D,EAAQ0a,aAyDR,WACEra,KAAK8Y,gBAAkB3W,EAAOuX,YAAcvX,EAAOsZ,QAC/Czb,KAAKW,QAAQH,EAAOC,KAAKC,IAAIV,KAAKW,QAAQC,OAAOZ,KAAKK,MAC1DL,KAAKK,KAAO,MA3DdV,EAAQob,iBA8DR,WACE,GAAI/a,KAAKuC,QACP,MAAMvC,KAAKwO,oBAAoB,+CA9DnC,IAAI6M,EAAgBhV,EAAQ,MAExB7F,EAAS6F,EAAQ,KAEjBlE,EAIJ,SAAiCoE,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJjtBO,CAAwBd,EAAQ,KAE7C,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,I,kCChBlLhH,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ2b,WAAQ,EAgChB3b,EAAQ2b,MA/BM,CAAC,SAAUI,EAAM/a,GAG7B,GAFkC,SAAb+a,EAAK5a,MAAmBH,EAAOgb,WAAahb,EAAOib,iBAAgC,gBAAbF,EAAK5a,KAAyBH,EAAOoW,uBAAsC,SAAb2E,EAAK5a,KAAkBH,EAAOuU,sBAAyC,iBAAjBwG,EAAK3N,SAA8BpN,EAAOkb,yBAA+D,IAApClb,EAAON,KAAK0H,aAAaxH,QAA6B,eAAbmb,EAAK5a,KAAwBH,EAAOqE,wBAI/V,OADArE,EAAOO,UACA,GAER,SAAUwa,EAAM/a,GACjB,GAAIA,EAAOwI,wBAA6D,IAAnCxI,EAAON,KAAKyb,YAAYvb,OAE3D,OADAI,EAAO2B,YAAY3B,EAAON,KAAKyb,YAAY,KACpC,GAER,SAAUJ,EAAM/a,GACjB,GAAIA,EAAOob,WAOT,MANiB,SAAbL,EAAK5a,IACPH,EAAO2B,YAAY3B,EAAON,KAAK+L,OAE/BzL,EAAO2B,YAAY3B,EAAON,KAAK6L,OAG1B,GAER,SAAUwP,EAAM/a,GACjB,GAAIA,EAAOqb,kBAAiC,eAAbN,EAAK5a,KAAqC,cAAb4a,EAAK5a,MAAqC,SAAb4a,EAAK5a,MAAmBH,EAAOwE,UAAYxE,EAAOyN,6BAKzI,OAJAsN,EAAKpZ,YAAY,CACfqB,KAAM,iBACN1B,KAAM,MAED,K,8DChCXxC,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQsc,aAyBR,SAAsBC,GACpBlc,KAAK+a,mBAEL,IAAMjb,EAAQE,KAAKE,gBAAgBgc,GAGjChZ,EACElD,KADFkD,WAGF,GAAIA,EAAW8B,yBAA2B9B,EAAWgS,sBAAwBhS,EAAWiZ,4BAA8BjZ,EAAWC,8BAAgCnD,KAAKoc,gBACpK,OAAOlZ,EAAW+Y,aAAanc,GAC1B,GAAIE,KAAK8C,WAAW,gBAAkB9C,KAAKqc,gBAAkBnZ,EAAWoZ,kBAAiC,SAAbtc,KAAKc,IAEtG,OADId,KAAKK,MAAMP,EAAM8H,KAAK5H,KAAKK,MACxBL,KAAKsD,gCAAgCxD,GACvC,GAAI6C,MAAMC,QAAQ5C,KAAKa,WAC5B,OAAOb,KAAKuc,uBAAuBzc,GAC9B,GAAIE,KAAKiV,qBAAsB,CACpC,IAAM5U,EAAOL,KAAKK,KACZmc,EAA0Bnc,KAAUL,KAAKgF,yBAA8C,MAAnB3E,EAAK6B,YAE/E,OADAlC,KAAKsC,YAAYnC,EAAEuE,eAAe8X,EAA0B,CAACnc,GAAQ,KAC9DL,KAAKiP,iBAAiB,OAAQnP,GAErC,MAAM,IAAI0C,MAAM,2GA9CpB7C,EAAQ8c,iBAkDR,SAA0BC,EAAM5c,GAAO,MACrCE,KAAKwb,kBAAkBkB,EAAM5c,EAAMS,QACnC,IAAMQ,EAAQ,IACd,EAAAf,KAAKa,WAAU0a,OAAf,SAAsBmB,EAAM,GAA5B,SAAkC5c,KAElC,IAAK,IAAIqN,EAAI,EAAGA,EAAIrN,EAAMS,OAAQ4M,IAAK,CACrC,IAAMwP,EAAKD,EAAOvP,EACZ1M,EAAOT,KAAK4c,WAAWD,GAC7B5b,EAAM6G,KAAKnH,GAEPT,KAAKyM,SAAWzM,KAAKyM,QAAQoQ,OAC/Bpc,EAAKga,YAAYza,KAAKyM,SAM1B,IAFA,IAAM8N,EAAWva,KAAK6a,oBAEtB,MAAmB9Z,EAAnB,eAA0B,CAArB,IAAMN,EAAI,KACbA,EAAKmD,WACLnD,EAAKwD,MAAM,aAFa,UAIFsW,GAJE,IAIxB,2BAAgC,SACtBK,WAAWna,GAAM,IALH,+BAS1B,OAAOM,GA3ETpB,EAAQ4c,uBA8ER,SAAgCzc,GAC9B,OAAOE,KAAKyc,iBAAiBzc,KAAKc,IAAKhB,IA9EzCH,EAAQyG,sBAiFR,SAA+BtG,GAC7B,OAAOE,KAAKyc,iBAAiBzc,KAAKc,IAAM,EAAGhB,IAjF7CH,EAAQqB,YAoFR,SAAqBkb,GACnBlc,KAAK+a,mBAEL,IAAMjb,EAAQE,KAAKE,gBAAgBgc,GAGjChZ,EACElD,KADFkD,WAGF,GAAIA,EAAW8B,yBAA2B9B,EAAWgS,sBAAwBhS,EAAWiZ,4BAA8BjZ,EAAWC,8BAAgCnD,KAAKoc,gBACpK,OAAOlZ,EAAWlC,YAAYlB,EAAMgN,KAAI,SAAAzM,GACtC,OAAOF,EAAE4C,aAAa1C,GAAQF,EAAEiD,oBAAoB/C,GAAQA,MAEzD,GAAIL,KAAK8C,WAAW,gBAAkB9C,KAAKqc,iBAAmBnZ,EAAWmZ,gBAAkBnZ,EAAWoZ,kBAAiC,SAAbtc,KAAKc,IAAgB,CACpJ,GAAId,KAAKK,KAAM,CACb,IAAMA,EAAOL,KAAKK,KAEhB+D,EACEpE,KADFoE,MAGF,GAAIA,EAAM3D,KAAKqc,YAIb,OAHA3c,EAAE4c,iBAAiB1c,GACnBL,KAAKsC,YAAYnC,EAAEwE,eAAexE,EAAEsE,wBAAwB,GAAIpE,GAAO,KACvEL,KAAKU,IAAI,eAAeM,YAAYlB,GAC7B,CAACE,MAGNkD,EAAWwK,SAAS,CACtB3B,UAAU,EACVjL,IAAKT,MAEL+D,EAAQA,EAAMzD,QAGhB,IAAMqc,EAAO5Y,EAAMqB,gCACnB3F,EAAM6T,QAAQxT,EAAEiD,oBAAoBjD,EAAE2F,qBAAqB,IAAK3F,EAAEyF,UAAUoX,GAAO3c,KACnFP,EAAM8H,KAAKzH,EAAEiD,oBAAoBjD,EAAEyF,UAAUoX,KAG/C,OAAOhd,KAAKsD,gCAAgCxD,GACvC,GAAI6C,MAAMC,QAAQ5C,KAAKa,WAC5B,OAAOb,KAAKoG,sBAAsBtG,GAC7B,GAAIE,KAAKiV,qBAAsB,CACpC,IAAM5U,EAAOL,KAAKK,KACZmc,EAA0Bnc,KAAUL,KAAKgF,yBAA8C,MAAnB3E,EAAK6B,YAE/E,OADAlC,KAAKsC,YAAYnC,EAAEuE,eAAe8X,EAA0B,CAACnc,GAAQ,KAC9DL,KAAK0F,cAAc,OAAQ5F,GAElC,MAAM,IAAI0C,MAAM,2GAnIpB7C,EAAQ6b,kBAuIR,SAA2ByB,EAAWC,GACpC,IAAKld,KAAKW,OAAQ,OAElB,IAHiD,EAG3CI,EAAQP,EAAOC,KAAKC,IAAIV,KAAKW,QAHc,IAK1BI,GAL0B,IAKjD,2BAA8B,KAAhBN,EAAgB,gBACxBA,EAAKK,KAAOmc,IACdxc,EAAKK,KAAOoc,IAPiC,gCAtInDvd,EAAQO,gBAkJR,SAAyBJ,GACvB,IAAKA,EACH,MAAO,GAGJ6C,MAAMC,QAAQ9C,KACjBA,EAAQ,CAACA,IAGX,IAAK,IAAIqN,EAAI,EAAGA,EAAIrN,EAAMS,OAAQ4M,IAAK,CACrC,IAAM9M,EAAOP,EAAMqN,GACfgQ,OAAG,EAYP,GAVK9c,EAEsB,kBAATA,EAChB8c,EAAM,6BACI9c,EAAKsD,KAENtD,aAAgB8B,EAAOC,UAChC+a,EAAM,gDAFNA,EAAM,iBAJNA,EAAM,iBASJA,EAAK,CACP,IAAMxZ,EAAOhB,MAAMC,QAAQvC,GAAQ,eAAiBA,EACpD,MAAM,IAAImC,MAAJ,oBAAuB2a,EAAvB,8BAAgDhQ,EAAhD,wBAAiExJ,KAI3E,OAAO7D,GA9KTH,EAAQsP,iBAiLR,SAA0BlB,EAASjO,GAajC,OAZAE,KAAK+a,mBAELjb,EAAQE,KAAKE,gBAAgBJ,GAEhBqC,EAAOC,QAAQ1B,IAAI,CAC9BwC,WAAYlD,KACZW,OAAQX,KAAKK,KACbQ,UAAWb,KAAKK,KAAK0N,GACrBA,UACAjN,IAAK,IACJgZ,WAAW9Z,KAAKyM,SAEP8P,uBAAuBzc,IA7LrCH,EAAQ+F,cAgMR,SAAuBqI,EAASjO,GAC9BE,KAAK+a,mBAEL,IAAMqC,EAAgBpd,KAAKE,gBAAgBJ,GAErCe,EAAYb,KAAKK,KAAK0N,GAU5B,OARa5L,EAAOC,QAAQ1B,IAAI,CAC9BwC,WAAYlD,KACZW,OAAQX,KAAKK,KACbQ,UAAWA,EACXkN,UACAjN,IAAKD,EAAUN,SACduZ,WAAW9Z,KAAKyM,SAEP5M,oBAAoBud,IA9MlCzd,EAAQ0d,MAiNR,WAAmC,IAApBjZ,EAAoB,uDAAZpE,KAAKoE,MACpBkZ,EAAU,IAAIC,EAASnb,QAAQpC,KAAMoE,GAC3C,OAAOkZ,EAAQE,OAjNjB,IAAIhd,EAAS6F,EAAQ,KAEjBkX,EAAWjX,EAAuBD,EAAQ,OAE1ClE,EAASmE,EAAuBD,EAAQ,KAExClG,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAASH,EAAuBC,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,K,sEC1BvF9G,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,aAAU,EAElB,IAAIjC,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,IAAMgX,EAAmB,CACvBrJ,qBADuB,SACF3T,EAAM6H,GACzB,IAAI7H,EAAKid,oBAAqBvd,EAAEwd,MAAMC,YAAYnd,EAAKJ,KAAKkF,OAAU9E,EAAKyC,WAAW+Q,wBAAtF,CAIA,GAAuB,SAAnBxT,EAAKJ,KAAKkF,KAAiB,CAC7B,IAAInB,EAAQ3D,EAAK2D,MAEjB,GACE,GAAIA,EAAM3D,KAAK0K,eAAiB/G,EAAM3D,KAAK2N,4BACzC,YAEKhK,EAAQA,EAAMzD,QAEnByD,GAAOkE,EAAMuV,kBAAkBjW,KAAKxD,EAAM3D,MAGhD,IAAM+J,EAAU/J,EAAK2D,MAAM4F,WAAWvJ,EAAKJ,KAAKkF,MAChD,GAAKiF,EAAL,CAlBgC,UAoBRA,EAAQC,oBApBA,IAoBhC,2BAAoD,CAClD,GADkD,QACpCrG,QAAUoG,EAAQ/J,KAAK2D,MAGnC,OAFAkE,EAAMwV,gBAAiB,OACvBrd,EAAKgZ,QAvBuB,8BA4B5BjP,IAAYlC,EAAMlE,MAAM4F,WAAWvJ,EAAKJ,KAAKkF,QACjD+C,EAAMb,SAAShH,EAAKJ,KAAKkF,MAAQiF,OAK/BuT,E,WACJ,WAAYtd,EAAM2D,GAAO,UACvBpE,KAAK6d,uBAAoB,EACzB7d,KAAKyH,cAAW,EAChBzH,KAAK8d,oBAAiB,EACtB9d,KAAKge,YAAS,EACdhe,KAAKoE,WAAQ,EACbpE,KAAKS,UAAO,EACZT,KAAKie,iBAAc,EACnBje,KAAK6d,kBAAoB,GACzB7d,KAAKyH,SAAW,GAChBzH,KAAK8d,gBAAiB,EACtB9d,KAAKge,OAAS,GACdhe,KAAKoE,MAAQA,EACbpE,KAAKS,KAAOA,EACZT,KAAKie,aAAc,E,oDAGH7Z,GAChB,cAAkB3E,OAAOkI,KAAK3H,KAAKyH,UAAnC,eAA8C,CAAzC,IAAM3G,EAAG,KACN0J,EAAUxK,KAAKyH,SAAS3G,GAE9B,IAAKsD,EAAM8Z,wBAAwBpd,EAAK0J,EAAQlF,YAC9C,OAAO,EAIX,OAAO,I,4CAIP,IAAIlB,EAAQpE,KAAKS,KAAK2D,MAEtB,EAAG,CACD,IAAIpE,KAAKme,kBAAkB/Z,GAGzB,MAGF,GALEpE,KAAKge,OAAOpW,KAAKxD,GAKfpE,KAAK6d,kBAAkBlR,QAAQvI,EAAM3D,OAAS,EAChD,YAEK2D,EAAQA,EAAMzD,U,0CAIvB,IAAIF,EAAOT,KAAKoe,qBAEhB,GAAK3d,EAAL,CACA,IAAI4d,EAAc5d,EAAK2D,MAMvB,GAJIia,EAAY5d,OAASA,IACvB4d,EAAc5d,EAAK2D,MAAMzD,QAGvB0d,EAAY5d,KAAKiC,aAAe2b,EAAY5d,KAAK0K,aACnD,cAAmB1L,OAAOkI,KAAK3H,KAAKyH,UAApC,eAA+C,CAA1C,IAAMlC,EAAI,KACb,GAAK8Y,EAAYC,cAAc/Y,GAA/B,CACA,IAAMiF,EAAUxK,KAAKyH,SAASlC,GAE9B,GAAqB,UAAjBiF,EAAQhD,MAA+C,WAA3BgD,EAAQ/J,KAAKqW,UAM7C,GAF0B9W,KAAKue,2BAA2B/T,EAAQ/J,MAE5CK,KAAOL,EAAKK,IAAK,CACrCd,KAAKie,aAAc,EACnBxd,EAAO+J,EAAQ/J,KAFsB,UAIT+J,EAAQC,oBAJC,IAIrC,2BAAwD,KAA7C+T,EAA6C,QAClDxe,KAAKue,2BAA2BC,GAAe1d,IAAML,EAAKK,MAC5DL,EAAO+d,IAN0B,iCAa3C,OAAO/d,K,2CAIP,IACM2D,EADSpE,KAAKge,OACCxD,MACrB,GAAKpW,EAEL,GAAIA,EAAM3D,KAAK0K,aAAc,CAC3B,IAAInL,KAAKye,oBAAoBra,GAS3B,OAAOpE,KAAK0e,+BARZ,GAAI1e,KAAKoE,QAAUA,EAAO,OAG1B,IAFA,IAAMua,EAASva,EAAM3D,KAAKC,IAAI,QAAQA,IAAI,QAEjCyM,EAAI,EAAGA,EAAIwR,EAAOpe,OAAQ4M,IACjC,IAAIwR,EAAOxR,GAAG9M,KAAKue,YACnB,OAAOD,EAAOxR,QAKb,GAAI/I,EAAM3D,KAAKiC,YACpB,OAAO1C,KAAK0e,iC,qDAKd,IAAMta,EAAQpE,KAAKge,OAAOxD,MAC1B,GAAIpW,EAAO,OAAOpE,KAAKue,2BAA2Bna,EAAM3D,Q,iDAG/BA,GACzB,GACE,IAAKA,EAAKyC,YAAcP,MAAMC,QAAQnC,EAAKI,YAAcJ,EAAK4C,cAC5D,OAAO5C,QAEFA,EAAOA,EAAKyC,c,0CAGHkB,GAClB,cAAmB3E,OAAOkI,KAAK3H,KAAKyH,UAApC,eAA+C,CAA1C,IAAMlC,EAAI,KACb,GAAKnB,EAAMka,cAAc/Y,GAAzB,CACA,IAAMiF,EAAUxK,KAAKyH,SAASlC,GAC9B,GAAqB,UAAjBiF,EAAQhD,MAAoBgD,EAAQiN,SAAU,OAAO,GAG3D,OAAO,I,4BAKP,GADAzX,KAAKS,KAAKmE,SAAS6Y,EAAkBzd,OACjCA,KAAK8d,eAAT,CACA9d,KAAK6e,sBACL,IAAMC,EAAW9e,KAAK+e,oBACtB,GAAKD,GACDA,EAASxa,sBAAwBtE,KAAKS,KAAK6D,oBAA/C,CACA,IAAIc,EAAM0Z,EAAS1a,MAAM2K,sBAAsB,OACzCiQ,EAAa7e,EAAE8e,mBAAmB7Z,EAAKpF,KAAKS,KAAKJ,MARnD,EAUeye,EADF9e,KAAKie,YAAc,cAAgB,gBACd,CAACa,EAAStH,uBAAyBwH,EAAa7e,EAAE+e,oBAAoB,MAAO,CAACF,MAA7GG,EAVH,UAWExe,EAASX,KAAKS,KAAKyC,WAOzB,OALIvC,EAAO0b,gBAAkBrc,KAAKS,KAAKI,YAAcF,EAAON,KAAK+e,WAC/Dha,EAAMjF,EAAEkf,uBAAuBja,IAGjCpF,KAAKS,KAAK6B,YAAYnC,EAAEyF,UAAUR,IAC3B0Z,EAAStH,uBAAyB2H,EAASze,IAAI,QAAUye,EAASze,IAAI,6B,KAKjFf,EAAQyC,QAAU2b,G,8CCrMlBte,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ2f,YAyBR,WACE,GAAiB,SAAbtf,KAAKc,IACP,OAAOd,KAAK4c,WAAW,SAClB,GAAiB,UAAb5c,KAAKc,IACd,OAAOd,KAAK4c,WAAW,QAGzB,OAAO,MA/BTjd,EAAQoF,qBA0GR,WACE,IAAIhE,EAAQ,GAEZ,GAAIf,KAAKgc,gBACPjb,EAAQwe,EAAqBvf,KAAKU,IAAI,cAAeK,GACrDA,EAAQwe,EAAqBvf,KAAKU,IAAI,aAAcK,QAC/C,GAAIf,KAAKwf,kBAAoBxf,KAAK6U,SAAW7U,KAAK2b,UACvD5a,EAAQwe,EAAqBvf,KAAKU,IAAI,QAASK,QAC1C,GAAIf,KAAK0C,aAAe1C,KAAK8N,mBAClC/M,EAAQwe,EAAqBvf,KAAKU,IAAI,QAAQ8Z,MAAOzZ,OAChD,IAAIf,KAAKmL,aACd,OAAOnL,KAAKU,IAAI,QAAQqE,uBACf/E,KAAKyf,kBACd1e,EAAQwe,EAAqBvf,KAAKU,IAAI,SAAUK,GAChDA,EAAQwe,EAAqBvf,KAAKU,IAAI,WAAYK,IACzCf,KAAK0f,gBACd3e,EAAQwe,EAAqBvf,KAAKU,IAAI,QAASK,GACtCf,KAAK2f,oBACd5e,EAvDJ,SAAmC6e,EAAO7e,GAGxC,IAFA,IAAI8e,GAA2B,EAEtB1S,EAAIyS,EAAMrf,OAAS,EAAG4M,GAAK,EAAGA,IAAK,CAC1C,IACM2S,EADaF,EAAMzS,GACKzM,IAAI,cAC9Bqf,EAAiBC,EAAUF,GAE/B,GAAIC,EAAgB,CAClB,KAA8B,IAAvBA,EAAejf,KAAaif,EAAe7c,WAAW4K,oBAC3DiS,EAAiBA,EAAe7c,WAGlC,IAAM+c,EAAcF,EAAeG,iBAE/BH,EAAejf,IAAM,IAAMmf,EAAYjb,yBAA2Bib,EAAYnS,qBAChF/M,EAAQwe,EAAqBU,EAAalf,GAC1Cgf,EAAe7e,WAEf6e,EAAezd,YAAYyd,EAAe3b,MAAM+b,sBAChDpf,EAAQwe,EAAqBQ,EAAgBhf,SAEtC8e,GAA0B,WACnC,IAAMO,EAAkB,SAAlBA,EAAkBC,GAAS,OAAKA,EAAUvS,oBAAsBuS,EAAU3f,IAAI,QAAQ4f,KAAKF,IAE3EN,EAAWQ,KAAKF,KAGpCrf,EAAQwe,EAAqBO,EAAWA,EAAWvf,OAAS,GAAIQ,GAChE8e,GAA2B,GAPM,GAYvC,OAAO9e,EAqBGwf,CAA0BvgB,KAAKU,IAAI,SAAUK,GAErDA,EAAM6G,KAAK5H,MAGb,OAAOe,GAhITpB,EAAQid,WAmIR,SAAoB9b,GAClB,OAAOqB,EAAOC,QAAQ1B,IAAI,CACxBwC,WAAYlD,KAAKkD,WACjBvC,OAAQX,KAAKW,OACbE,UAAWb,KAAKa,UAChBkN,QAAS/N,KAAK+N,QACdjN,IAAKA,IACJgZ,WAAW9Z,KAAKyM,UAzIrB9M,EAAQugB,eA4IR,WACE,OAAOlgB,KAAK4c,WAAW5c,KAAKc,IAAM,IA5IpCnB,EAAQ6gB,eA+IR,WACE,OAAOxgB,KAAK4c,WAAW5c,KAAKc,IAAM,IA/IpCnB,EAAQ8gB,mBAkJR,WACE,IAAIC,EAAO1gB,KAAKc,IACZ6f,EAAU3gB,KAAK4c,aAAa8D,GAC1BE,EAAW,GAEjB,KAAOD,EAAQtgB,MACbugB,EAAShZ,KAAK+Y,GACdA,EAAU3gB,KAAK4c,aAAa8D,GAG9B,OAAOE,GA3JTjhB,EAAQkhB,mBA8JR,WACE,IAAIH,EAAO1gB,KAAKc,IACZ6f,EAAU3gB,KAAK4c,aAAa8D,GAC1BE,EAAW,GAEjB,KAAOD,EAAQtgB,MACbugB,EAAShZ,KAAK+Y,GACdA,EAAU3gB,KAAK4c,aAAa8D,GAG9B,OAAOE,GAvKTjhB,EAAQe,IA0KR,SAAaI,GAAqB,IAAhB2L,IAAgB,0DAChB,IAAZA,IAAkBA,EAAUzM,KAAKyM,SACrC,IAAMkG,EAAQ7R,EAAIggB,MAAM,KAExB,OAAqB,IAAjBnO,EAAMpS,OACDP,KAAK+gB,QAAQjgB,EAAK2L,GAElBzM,KAAKghB,YAAYrO,EAAOlG,IAhLnC9M,EAAQohB,QAoLR,SAAiBjgB,EAAK2L,GAAS,WACvBpM,EAAOL,KAAKK,KACZQ,EAAYR,EAAKS,GAEvB,OAAI6B,MAAMC,QAAQ/B,GACTA,EAAUiM,KAAI,SAACmU,EAAG9T,GACvB,OAAOhL,EAAOC,QAAQ1B,IAAI,CACxBqN,QAASjN,EACToC,WAAY,EACZvC,OAAQN,EACRQ,UAAWA,EACXC,IAAKqM,IACJ2M,WAAWrN,MAGTtK,EAAOC,QAAQ1B,IAAI,CACxBwC,WAAYlD,KACZW,OAAQN,EACRQ,UAAWR,EACXS,IAAKA,IACJgZ,WAAWrN,IAvMlB9M,EAAQqhB,YA2MR,SAAqBrO,EAAOlG,GAC1B,IADmC,EAC/BhM,EAAOT,KADwB,IAGhB2S,GAHgB,IAGnC,2BAA0B,KAAfuO,EAAe,QAEtBzgB,EADW,MAATygB,EACKzgB,EAAKyC,WAERP,MAAMC,QAAQnC,GACTA,EAAKygB,GAELzgB,EAAKC,IAAIwgB,EAAMzU,IAVO,8BAenC,OAAOhM,GAzNTd,EAAQ+H,sBA4NR,SAA+ByZ,GAC7B,OAAOhhB,EAAEuH,sBAAsB1H,KAAKK,KAAM8gB,IA5N5CxhB,EAAQyhB,2BA+NR,SAAoCD,GAClC,OAAOhhB,EAAEihB,2BAA2BphB,KAAKK,KAAM8gB,IA/NjDxhB,EAAQ0hB,0BAkOR,WAA0E,IAAvCF,EAAuC,wDAAnBG,EAAmB,wDAClE7gB,EAAOT,KACTuhB,EAAS,GAAGhQ,OAAO9Q,GACjB+gB,EAAM/hB,OAAOgiB,OAAO,MAE1B,KAAOF,EAAOhhB,QAAQ,CACpB,IAAMsH,EAAK0Z,EAAOG,QAClB,GAAK7Z,GACAA,EAAGxH,KAAR,CACA,IAAMsH,EAAOxH,EAAEuH,sBAAsBC,KAAKE,EAAGxH,KAAKsD,MAElD,GAAIkE,EAAGkC,eACL,GAAIoX,EAAY,CACd,IAAMQ,EAAOH,EAAI3Z,EAAGxH,KAAKkF,MAAQic,EAAI3Z,EAAGxH,KAAKkF,OAAS,GAEtDoc,EAAK/Z,KAAKC,QAEV2Z,EAAI3Z,EAAGxH,KAAKkF,MAAQsC,OAMxB,GAAIA,EAAGkP,sBAAP,CACE,IAAM6K,EAAc/Z,EAAGnH,IAAI,eAEvBkhB,EAAYxF,iBACdmF,EAAO3Z,KAAKga,OAJhB,CAUA,GAAIN,EAAW,CACb,GAAIzZ,EAAG0G,wBAAyB,CAC9BgT,EAAO3Z,KAAKC,EAAGnH,IAAI,OACnB,SAGF,GAAImH,EAAGyG,uBACL,SAIJ,GAAI3G,EACF,IAAK,IAAIwF,EAAI,EAAGA,EAAIxF,EAAKpH,OAAQ4M,IAAK,CACpC,IAAMrM,EAAM6G,EAAKwF,GACXiD,EAAQvI,EAAGnH,IAAII,IAEjB6B,MAAMC,QAAQwN,IAAUA,EAAM/P,QAChCkhB,EAASA,EAAOhQ,OAAOnB,OAM/B,OAAOoR,GAzRT7hB,EAAQkiB,+BA4RR,SAAwCV,GACtC,OAAOnhB,KAAKqhB,0BAA0BF,GAAY,IA3RpD,IAQgC5a,EAR5BpE,GAQ4BoE,EARIF,EAAQ,MAQSE,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GANnFpG,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAgBlL,SAAS8Y,EAAqB9e,EAAMM,GAClC,OAAIN,EAAaM,EAAMwQ,OAAO9Q,EAAKsE,wBAC5BhE,EAGT,SAASif,EAAUhS,GACjB,IAAI+R,EAECpd,MAAMC,QAAQoL,KACjBA,EAAa,CAACA,IAJa,UAOLA,GAPK,IAO7B,2BAAoC,KAAzBqS,EAAyB,QAClC,GAAIA,EAAUb,kBAAoBa,EAAU3d,aAAe2d,EAAUvS,oBAAsBuS,EAAUX,iBAAmBW,EAAUnL,qBAChI6K,EAAiBC,EAAUK,EAAU3f,IAAI,cACpC,GAAI2f,EAAUrE,gBAAiB,CACpC,IAAI8F,EAEJ/B,EAA0E,OAAxD+B,EAAa9B,EAAUK,EAAU3f,IAAI,gBAA0BohB,EAAa9B,EAAUK,EAAU3f,IAAI,mBACjH,GAAI2f,EAAUZ,iBAAkB,CACrC,IAAIsC,EAEJhC,EAAsE,OAApDgC,EAAc/B,EAAUK,EAAU3f,IAAI,WAAqBqhB,EAAc/B,EAAUK,EAAU3f,IAAI,iBAC1G2f,EAAU2B,qBACnBjC,EAAiBM,GAGnB,GAAIN,EACF,OAAOA,GAvBkB,8BA2B7B,OAAO,O,kCCtETtgB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQub,0BAUR,WACE,GAAwB,kBAAblb,KAAKc,IAAkB,OAClC,IAAMT,EAAOL,KAAKK,KAClB,IAAKA,EAAM,OACX,IAAM4hB,EAAW5hB,EAAK6hB,iBAChBC,EAAU9hB,EAAK+hB,gBACrB,IAAKH,IAAaE,EAAS,OAC3B,IAAME,EAAOriB,KAAK4c,WAAW5c,KAAKc,IAAM,GAClCwhB,EAAOtiB,KAAK4c,WAAW5c,KAAKc,IAAM,GAClCyhB,EAAUC,QAAQH,EAAKhiB,MACvBoiB,EAAUD,QAAQF,EAAKjiB,MAEzBkiB,IAAYE,EACdJ,EAAKK,YAAY,WAAYT,GACpBQ,IAAYF,GACrBD,EAAKI,YAAY,UAAWP,IAxBhCxiB,EAAQgjB,WA4BR,SAAoBhf,EAAMif,EAAS/gB,GACjC1B,EAAEwiB,WAAW3iB,KAAKK,KAAMsD,EAAMif,EAAS/gB,IA5BzClC,EAAQ+iB,YA+BR,SAAqB/e,EAAMkf,GACzB1iB,EAAEuiB,YAAY1iB,KAAKK,KAAMsD,EAAMkf,IA9BjC,IAAI1iB,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,I,8CCTlLhH,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQmjB,QAAUA,EAClBnjB,EAAQojB,OAASA,EACjBpjB,EAAQqjB,MAqIR,SAAeC,GAGb,IAH6C,IAAtBC,EAAsB,uDAAb,GAAIC,EAAS,uCACvCC,EAAc,GAEXjW,EAAI,EAAGA,EAAI8V,EAAS1iB,OAAQ4M,IAAK,CACxC,IAAMkW,EAAUJ,EAAS9V,GACnB7E,EAAQ4a,EAAO/V,GACrB2V,EAAQO,GAER,cAAmB5jB,OAAOkI,KAAK0b,GAA/B,eAAyC,CAApC,IAAM1f,EAAI,KACT2f,EAAcD,EAAQ1f,IAEtB2E,GAAS6a,KACXG,EAAcC,EAAuBD,EAAahb,EAAO6a,IAG3D,IAAMK,EAAcJ,EAAYzf,GAAQyf,EAAYzf,IAAS,GAC7D8f,EAAUD,EAAaF,IAI3B,OAAOF,GAvJT,IAAIM,EAAevc,EAAwBd,EAAQ,MAE/ClG,EAAIgH,EAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASU,EAAwBZ,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAyE,OAA7D8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAkBA,EAE9tB,SAASkc,EAAQO,GACf,GAAIA,EAAQM,UAAW,OAAON,EAC9BA,EAAQM,WAAY,EAEpB,cAAuBlkB,OAAOkI,KAAK0b,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAMjR,EAAQiR,EAAS9C,MAAM,KAC7B,GAAqB,IAAjBnO,EAAMpS,OAAV,CACA,IAAMoY,EAAM0K,EAAQO,UACbP,EAAQO,GAL4B,UAOxBjR,GAPwB,IAO3C,2BAA0B,CACxB0Q,EADwB,SACR1K,GARyB,iCAY7CoK,EAAOM,UACAA,EAAQ7c,WAgKjB,SAA+BD,GAC7B,cAAkB9G,OAAOkI,KAAKpB,GAA9B,eAAoC,CAA/B,IAAMzF,EAAG,KACZ,IAAI+iB,EAAgB/iB,GAApB,CACA,IAAM6X,EAAMpS,EAAIzF,GAEG,oBAAR6X,IACTpS,EAAIzF,GAAO,CACTgjB,MAAOnL,MAtKboL,CAAsBV,GACtBW,EAAqBX,GAErB,cAAuB5jB,OAAOkI,KAAK0b,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAMT,EAAUO,EAAaE,GAC7B,GAAKT,EAAL,CAGA,IAFA,IAAMxK,EAAM0K,EAAQO,GAEpB,MAAmBnkB,OAAOkI,KAAKgR,GAA/B,eAAqC,CAAhC,IAAMhV,EAAI,KACbgV,EAAIhV,GAAQsgB,EAAUd,EAASxK,EAAIhV,IAKrC,UAFO0f,EAAQO,GAEXT,EAAQe,MAAO,WACEf,EAAQe,OADV,IACjB,2BAAkC,KAAvBvgB,EAAuB,QAC5B0f,EAAQ1f,GACV8f,EAAUJ,EAAQ1f,GAAOgV,GAEzB0K,EAAQ1f,GAAQgV,GALH,oCASjB8K,EAAUJ,EAAS1K,KAIvB,cAAuBlZ,OAAOkI,KAAK0b,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACjB,IAAIC,EAAgBD,GAApB,CACA,IAAMjL,EAAM0K,EAAQO,GAChBO,EAAUhkB,EAAEikB,mBAAmBR,GAC7BS,EAAgBlkB,EAAEmkB,gBAAgBV,GAOxC,GALIS,IACFE,QAAQC,MAAR,8BAAqCZ,EAArC,uCAA4ES,IAC5EF,EAAU,CAACE,IAGRF,EAAL,QACOd,EAAQO,GAZ4B,UAcvBO,GAduB,IAc3C,2BAA6B,KAAlBM,EAAkB,QACrB1b,EAAWsa,EAAQoB,GAErB1b,EACF0a,EAAU1a,EAAU4P,GAEpB0K,EAAQoB,GAAShlB,OAAOilB,OAAO,GAAI/L,IApBI,iCAyB7C,cAAuBlZ,OAAOkI,KAAK0b,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KACbC,EAAgBD,IACpBI,EAAqBX,EAAQO,IAG/B,OAAOP,EAGT,SAASN,EAAOM,GACd,IAAIA,EAAQsB,UAAZ,CAEA,GAAuB,oBAAZtB,EACT,MAAM,IAAI7gB,MAAM,6HAGlB,cAAuB/C,OAAOkI,KAAK0b,GAAnC,eAA6C,CAAxC,IAAMO,EAAQ,KAKjB,GAJiB,UAAbA,GAAqC,SAAbA,GAC1BgB,EAAuBhB,EAAUP,EAAQO,KAGvCC,EAAgBD,GAApB,CAEA,GAAIzjB,EAAE0kB,MAAMlY,QAAQiX,GAAY,EAC9B,MAAM,IAAIphB,MAAJ,kDAAqDohB,EAArD,+BAGR,IAAMX,EAAWI,EAAQO,GAEzB,GAAwB,kBAAbX,EACT,cAAyBxjB,OAAOkI,KAAKsb,GAArC,eAAgD,CAA3C,IAAM6B,EAAU,KACnB,GAAmB,UAAfA,GAAyC,SAAfA,EAG5B,MAAM,IAAItiB,MAAM,8DAAgE,GAAhE,OAAmEohB,EAAnE,0CAA6GkB,IAF7HF,EAAuB,GAAD,OAAIhB,EAAJ,YAAgBkB,GAAc7B,EAAS6B,MAQrEzB,EAAQsB,WAAY,GAGtB,SAASC,EAAuBnkB,EAAMyI,GACpC,IADyC,EACnCyP,EAAM,GAAGpH,OAAOrI,GADmB,IAGxByP,GAHwB,IAGzC,2BAAsB,KAAXC,EAAW,QACpB,GAAkB,oBAAPA,EACT,MAAM,IAAImM,UAAJ,wCAA+CtkB,EAA/C,6BAAwEmY,KALzC,+BAiC3C,SAAS2K,EAAuByB,EAAY1c,EAAO6a,GAGjD,IAFA,IAAM8B,EAAa,GADuC,aAGrD,IAAMnkB,EAAG,KACR6X,EAAMqM,EAAWlkB,GACrB,IAAK6B,MAAMC,QAAQ+V,GAAM,iBACzBA,EAAMA,EAAI7L,KAAI,SAAU8L,GACtB,IAAIsM,EAAQtM,EAgBZ,OAdItQ,IACF4c,EAAQ,SAAUzkB,GAChB,OAAOmY,EAAG3R,KAAKqB,EAAO7H,EAAM6H,KAI5B6a,IACF+B,EAAQ/B,EAAQ7a,EAAMxH,IAAKA,EAAKokB,IAG9BA,IAAUtM,IACZsM,EAAMC,SAAW,kBAAMvM,EAAGuM,aAGrBD,KAETD,EAAWnkB,GAAO6X,GAtBpB,MAAkBlZ,OAAOkI,KAAKqd,GAA9B,eAA2C,IAyB3C,OAAOC,EAgBT,SAASjB,EAAqBzd,GACxBA,EAAIud,QAAUnhB,MAAMC,QAAQ2D,EAAIud,SAAQvd,EAAIud,MAAQ,CAACvd,EAAIud,QACzDvd,EAAI6e,OAASziB,MAAMC,QAAQ2D,EAAI6e,QAAO7e,EAAI6e,KAAO,CAAC7e,EAAI6e,OAG5D,SAASnB,EAAUd,EAASvK,GAC1B,IAAMsM,EAAQ,SAAUzkB,GACtB,GAAI0iB,EAAQkC,UAAU5kB,GACpB,OAAOmY,EAAG7L,MAAM/M,KAAMslB,YAM1B,OAFAJ,EAAMC,SAAW,kBAAMvM,EAAGuM,YAEnBD,EAGT,SAASrB,EAAgB/iB,GACvB,MAAe,MAAXA,EAAI,KACI,UAARA,GAA2B,SAARA,GAA0B,eAARA,IAE7B,aAARA,GAA8B,YAARA,GAA6B,aAARA,GAA8B,cAARA,IAOvE,SAAS2iB,EAAU8B,EAAMC,GACvB,cAAkB/lB,OAAOkI,KAAK6d,GAA9B,eAAoC,CAA/B,IAAM1kB,EAAG,KACZykB,EAAKzkB,GAAO,GAAGyQ,OAAOgU,EAAKzkB,IAAQ,GAAI0kB,EAAI1kB,O,sDC3O/CrB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,aAAU,E,IAEZqjB,E,uJAMF,MAAM,IAAIjjB,MAAM,mD,iCAGPnC,EAAM8c,GAAwB,IAAnB3a,EAAmB,uDAAXuiB,UAC5B,OAAO,IAAIviB,EAAM2a,O,KAKrBxd,EAAQyC,QAAUqjB,G,iCCpBlBhmB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQ+lB,MASR,WACEC,IACAC,KAVFjmB,EAAQgmB,UAAYA,EACpBhmB,EAAQimB,WAAaA,EACrBjmB,EAAQyE,MAAQzE,EAAQc,UAAO,EAC/B,IAAIA,EAAO,IAAI2G,QACfzH,EAAQc,KAAOA,EACf,IAAI2D,EAAQ,IAAIgD,QAQhB,SAASue,IACPhmB,EAAQc,KAAOA,EAAO,IAAI2G,QAG5B,SAASwe,IACPjmB,EAAQyE,MAAQA,EAAQ,IAAIgD,QAZ9BzH,EAAQyE,MAAQA,G,iCCVhB3E,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQkmB,kBAAoBlmB,EAAQmmB,6BAA+BnmB,EAAQomB,qBAAuBpmB,EAAQqmB,eAAiBrmB,EAAQsmB,aAAetmB,EAAQumB,KAAOvmB,EAAQwmB,KAAOxmB,EAAQymB,UAAYzmB,EAAQ0mB,KAAO1mB,EAAQ2mB,IAAM3mB,EAAQ4mB,YAAc5mB,EAAQ6mB,WAAa7mB,EAAQ8mB,MAAQ9mB,EAAQ+mB,WAAa/mB,EAAQgnB,UAAYhnB,EAAQinB,kBAAoBjnB,EAAQknB,2BAA6BlnB,EAAQyU,0BAAuB,EAEra,IAAIjU,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,IAAM2N,EAAuB,CAC3B8P,MAAO,CAAC,aAAc,iBAEtBmB,UAH2B,SAGjB5kB,EAAMgY,GAAM,IAElBpY,EAEEI,EAFFJ,KACAM,EACEF,EADFE,OAGF,IAAKR,EAAE4J,aAAa1J,EAAMoY,KAAUtY,EAAE8T,sBAAsBtT,EAAQ8X,GAAO,CACzE,IAAItY,EAAEud,gBAAgBrd,EAAMoY,GAG1B,OAAO,EAFP,GAAItY,EAAEwd,MAAMC,YAAYvd,EAAKkF,MAAO,OAAO,EAM/C,OAAOpF,EAAE2mB,aAAazmB,EAAMM,EAAQF,EAAKyC,WAAWvC,UAIxDhB,EAAQyU,qBAAuBA,EAC/B,IAAMyS,EAA6B,CACjC3C,MAAO,CAAC,oBAERmB,UAHiC,YAM9B,IAFDhlB,EAEC,EAFDA,KACAM,EACC,EADDA,OAEA,OAAOR,EAAEyJ,mBAAmBvJ,IAASF,EAAE2mB,aAAazmB,EAAMM,KAI9DhB,EAAQknB,2BAA6BA,EACrC,IAAMD,EAAoB,CACxB1C,MAAO,CAAC,cAERmB,UAHwB,SAGd5kB,GAAM,IAEZJ,EAEEI,EAFFJ,KACAM,EACEF,EADFE,OAEIomB,EAActmB,EAAKyC,WAAWvC,OACpC,OAAOR,EAAE4J,aAAa1J,IAASF,EAAE6mB,UAAU3mB,EAAMM,EAAQomB,KAI7DpnB,EAAQinB,kBAAoBA,EAC5B,IAAMD,EAAY,CAChBzC,MAAO,CAAC,aAERmB,UAHgB,YAMb,IAFDhlB,EAEC,EAFDA,KACAM,EACC,EADDA,OAEA,GAAIR,EAAEkD,YAAYhD,GAAO,CACvB,GAAIF,EAAE0b,sBAAsBxb,GAAO,CACjC,GAAIF,EAAE8mB,gBAAgBtmB,EAAQ,CAC5BuL,KAAM7L,IACJ,OAAO,EACX,GAAIF,EAAEmc,eAAe3b,EAAQ,CAC3BsH,KAAM5H,IACJ,OAAO,EAGb,OAAO,EAEP,OAAO,IAKbV,EAAQgnB,UAAYA,EACpB,IAAMD,EAAa,CACjBxC,MAAO,CAAC,cAERmB,UAHiB,SAGP5kB,GACR,OAAIA,EAAKsJ,eACAtJ,EAAK8J,yBAELpK,EAAE4C,aAAatC,EAAKJ,QAKjCV,EAAQ+mB,WAAaA,EACrB,IAAMD,EAAQ,CACZvC,MAAO,CAAC,WAAY,WAEpBmB,UAHY,SAGF5kB,GACR,OAAON,EAAE+mB,QAAQzmB,EAAKJ,KAAMI,EAAKE,UAIrChB,EAAQ8mB,MAAQA,EAChB,IAAMD,EAAa,CACjBnB,UADiB,SACP5kB,GACR,OAAON,EAAE2mB,aAAarmB,EAAKJ,KAAMI,EAAKE,UAI1ChB,EAAQ6mB,WAAaA,EACrB,IAAMD,EAAc,CAClBlB,UADkB,SACR5kB,GACR,OAAON,EAAEgnB,cAAc1mB,EAAKJ,QAIhCV,EAAQ4mB,YAAcA,EACtB,IAAMD,EAAM,CACVpC,MAAO,CAAC,uBAERmB,UAHU,SAGA5kB,GACR,OAAON,EAAEinB,MAAM3mB,EAAKJ,QAIxBV,EAAQ2mB,IAAMA,EAOd3mB,EAAQ0mB,KANK,CACXhB,UADW,SACD5kB,GACR,OAAOA,EAAKJ,QAAUI,EAAKJ,KAAKmB,MAWpC7B,EAAQymB,UANU,CAChBf,UADgB,SACN5kB,GACR,OAAQA,EAAK4mB,WAWjB1nB,EAAQwmB,KANK,CACXd,UADW,SACD5kB,EAAMgY,GACd,OAAOhY,EAAK2D,MAAMkjB,OAAO7mB,EAAKJ,KAAMoY,KAKxC,IAAMyN,EAAO,CACXhC,MAAO,CAAC,OAAQ,oBAAqB,oBAAqB,mBAE1DmB,UAHW,YAKR,IADDhlB,EACC,EADDA,KAEA,QAAIF,EAAEonB,OAAOlnB,KAEFF,EAAEsV,oBAAoBpV,GACJ,SAApBA,EAAKmnB,YAA6C,WAApBnnB,EAAKmnB,WACjCrnB,EAAE4W,oBAAoB1W,GACJ,SAApBA,EAAKonB,aACHtnB,EAAE0V,kBAAkBxV,KACF,SAApBA,EAAKmnB,YAA6C,WAApBnnB,EAAKmnB,eAOhD7nB,EAAQumB,KAAOA,EASfvmB,EAAQsmB,aARa,CACnB/B,MAAO,CAAC,eAERmB,UAHmB,SAGT5kB,GACR,OAAOA,EAAKyC,YAAczC,EAAKyC,WAAWwkB,oBAa9C/nB,EAAQqmB,eARe,CACrB9B,MAAO,CAAC,eAERmB,UAHqB,SAGX5kB,GACR,OAAOA,EAAKyC,YAAczC,EAAKyC,WAAWwI,uBAQ9C/L,EAAQomB,qBAHqB,CAC3B7B,MAAO,CAAC,yBAMVvkB,EAAQmmB,6BAH6B,CACnC5B,MAAO,CAAC,gCAaVvkB,EAAQkmB,kBAVkB,CACxB3B,MAAO,CAAC,kBAERmB,UAHwB,YAMtB,OAAsB,IADrB,EADDhlB,KAEYsnB,S,qEC3MhBloB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,aAAU,EAElB,IAAIwlB,EAAWthB,EAAuBD,EAAQ,MAE1ClE,EAASmE,EAAuBD,EAAQ,KAExCwhB,EAAWvhB,EAAuBD,EAAQ,MAE1CyhB,EAAWxhB,EAAuBD,EAAQ,MAE1ClG,EAMJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EANttBO,CAAwBd,EAAQ,KAEpC7F,EAAS6F,EAAQ,KAErB,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAASH,EAAuBC,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAEvF,SAASwhB,EAAgB1nB,EAAMsS,GAC7B,OAAgB,MAARtS,OAAe,EAASA,EAAKsD,MACnC,QACE,GAAIxD,EAAE6nB,oBAAoB3nB,GACxB,IAAKF,EAAE8nB,uBAAuB5nB,IAASF,EAAEgc,yBAAyB9b,IAASF,EAAEsV,oBAAoBpV,KAAUA,EAAKqV,OAC9GqS,EAAgB1nB,EAAKqV,OAAQ/C,QACxB,IAAKxS,EAAEgc,yBAAyB9b,IAASF,EAAEsV,oBAAoBpV,KAAUA,EAAK6nB,YAAc7nB,EAAK6nB,WAAW3nB,OAAQ,WACzGF,EAAK6nB,YADoG,IACzH,4BAAiCH,EAAjC,QAAoDpV,IADqE,oCAE/GxS,EAAEgD,2BAA2B9C,IAASF,EAAEgc,yBAAyB9b,KAAUA,EAAKuhB,aAC1FmG,EAAgB1nB,EAAKuhB,YAAajP,QAE3BxS,EAAEgoB,kBAAkB9nB,GAC7B0nB,EAAgB1nB,EAAK+nB,MAAOzV,GACnBxS,EAAEmK,UAAUjK,IACrBsS,EAAM/K,KAAKvH,EAAKT,OAGlB,MAEF,IAAK,mBACL,IAAK,2BACL,IAAK,sBACHmoB,EAAgB1nB,EAAKwJ,OAAQ8I,GAC7BoV,EAAgB1nB,EAAKyJ,SAAU6I,GAC/B,MAEF,IAAK,aACL,IAAK,gBACHA,EAAM/K,KAAKvH,EAAKkF,MAChB,MAEF,IAAK,iBACL,IAAK,yBACL,IAAK,gBACHwiB,EAAgB1nB,EAAKmF,OAAQmN,GAC7B,MAEF,IAAK,mBACL,IAAK,gBAAL,UACkBtS,EAAKgoB,YADvB,IACE,2BAAiC,CAC/BN,EAD+B,QACZpV,IAFvB,8BAKE,MAEF,IAAK,gBACL,IAAK,cACHoV,EAAgB1nB,EAAK6K,SAAUyH,GAC/B,MAEF,IAAK,iBACL,IAAK,eACL,IAAK,gBACL,IAAK,cACL,IAAK,uBACL,IAAK,qBACHoV,EAAgB1nB,EAAKS,IAAK6R,GAC1B,MAEF,IAAK,iBACHA,EAAM/K,KAAK,QACX,MAEF,IAAK,QACH+K,EAAM/K,KAAK,SACX,MAEF,IAAK,SACH+K,EAAM/K,KAAK,UACX,MAEF,IAAK,eACH+K,EAAM/K,KAAK,MACX,MAEF,IAAK,kBACH+K,EAAM/K,KAAK,SACXmgB,EAAgB1nB,EAAK6K,SAAUyH,GAC/B,MAEF,IAAK,kBACHA,EAAM/K,KAAK,SACXmgB,EAAgB1nB,EAAK6K,SAAUyH,GAC/B,MAEF,IAAK,uBACHoV,EAAgB1nB,EAAK6L,KAAMyG,GAC3B,MAEF,IAAK,qBACHoV,EAAgB1nB,EAAKwH,GAAI8K,GACzB,MAEF,IAAK,qBACL,IAAK,sBACL,IAAK,kBACL,IAAK,mBAIL,IAAK,cACHoV,EAAgB1nB,EAAKwH,GAAI8K,GACzB,MAEF,IAAK,0BACHoV,EAAgB1nB,EAAK6B,WAAYyQ,GACjC,MAEF,IAAK,kBACL,IAAK,mBACHoV,EAAgB1nB,EAAK6K,SAAUyH,GAC/B,MAEF,IAAK,eACHoV,EAAgB1nB,EAAKioB,KAAM3V,GAC3BoV,EAAgB1nB,EAAKyJ,SAAU6I,GAC/B,MAEF,IAAK,aACHoV,EAAgB1nB,EAAKkoB,eAAgB5V,GACrC,MAEF,IAAK,oBACHA,EAAM/K,KAAKvH,EAAKkF,MAChB,MAEF,IAAK,cACHwiB,EAAgB1nB,EAAKmoB,gBAAiB7V,GACtC,MAEF,IAAK,qBACHA,EAAM/K,KAAK,YACX,MAEF,IAAK,oBACHmgB,EAAgB1nB,EAAKooB,UAAW9V,GAChCoV,EAAgB1nB,EAAKkF,KAAMoN,IAKjC,IAAM+V,EAAmB,CACvBC,IADuB,SACnBloB,GAAM,UACUN,EAAEyoB,eADZ,IACR,2BAAmC,KAAxB9nB,EAAwB,QAC3BkH,EAASvH,EAAKC,IAAII,GAExB,GAAIkH,EAAOof,SACW3mB,EAAK2D,MAAME,qBAAuB7D,EAAK2D,MAAMkU,oBACrDuQ,gBAAgB,MAAO7gB,IAN/B,gCAWV8gB,YAZuB,SAYXroB,GACNA,EAAK0mB,kBACL1mB,EAAKsW,wBACMtW,EAAK2D,MAAME,qBAAuB7D,EAAK2D,MAAMkU,oBACrDyQ,oBAAoBtoB,KAG7B2T,qBAnBuB,SAmBF3T,EAAM6H,GACzBA,EAAM0O,WAAWpP,KAAKnH,IAGxBuoB,cAvBuB,SAuBTvoB,EAAM6H,GAClB,IAAM4D,EAAOzL,EAAKC,IAAI,SAElBwL,EAAK4Q,aAAe5Q,EAAKnC,iBAC3BzB,EAAMmC,mBAAmB7C,KAAKnH,IAIlCwoB,kBAAmB,CACjB7D,KADiB,SACZ3kB,GAAM,IAEPJ,EAEEI,EAFFJ,KACA+D,EACE3D,EADF2D,MAEF,IAAIjE,EAAE8nB,uBAAuB5nB,GAA7B,CACA,IAAM2H,EAAS3H,EAAKuhB,YAEpB,GAAIzhB,EAAE+oB,mBAAmBlhB,IAAW7H,EAAEoO,sBAAsBvG,GAAS,CACnE,IAAMH,EAAKG,EAAOH,GAClB,IAAKA,EAAI,OACT,IAAM2C,EAAUpG,EAAM4F,WAAWnC,EAAGtC,MAChCiF,GAASA,EAAQ2e,UAAU1oB,QAC1B,GAAIN,EAAE0b,sBAAsB7T,GAAS,WACvBA,EAAOD,cADgB,IAC1C,2BACE,IADsC,IAA7BqhB,EAA6B,QACtC,MAAmB3pB,OAAOkI,KAAKxH,EAAEuH,sBAAsB0hB,IAAvD,eAA+D,CAA1D,IAAM7jB,EAAI,KACPiF,EAAUpG,EAAM4F,WAAWzE,GAC7BiF,GAASA,EAAQ2e,UAAU1oB,IAJO,mCAYhD4oB,iBAzDuB,SAyDN5oB,GACfA,EAAK2D,MAAMklB,iBAAiBP,oBAAoBtoB,IAGlD8oB,qBA7DuB,SA6DF9oB,EAAM6H,GACzBA,EAAMkhB,YAAY5hB,KAAKnH,IAGzBgpB,iBAjEuB,SAiENhpB,EAAM6H,GACrBA,EAAMmC,mBAAmB7C,KAAKnH,IAGhCipB,gBArEuB,SAqEPjpB,EAAM6H,GACO,WAAvB7H,EAAKJ,KAAK4K,UACZ3C,EAAMmC,mBAAmB7C,KAAKnH,IAIlC8lB,YA3EuB,SA2EX9lB,GACV,IAAI2D,EAAQ3D,EAAK2D,MAKjB,GAJIA,EAAM3D,OAASA,IAAM2D,EAAQA,EAAMzD,QACxByD,EAAMklB,iBACdP,oBAAoBtoB,GAEvBA,EAAKyoB,sBAAwBzoB,EAAKJ,KAAKwH,GAAI,CAC7C,IACMtC,EADK9E,EAAKJ,KAAKwH,GACLtC,KAChB9E,EAAK2D,MAAMqD,SAASlC,GAAQ9E,EAAK2D,MAAMzD,OAAOqJ,WAAWzE,KAI7DokB,YAxFuB,SAwFXlpB,GACVA,EAAK2D,MAAMykB,gBAAgB,MAAOpoB,IAGpC4G,SA5FuB,SA4Fd5G,GACHA,EAAK6N,wBAA0B7N,EAAKkG,IAAI,QAAUlG,EAAKC,IAAI,MAAML,KAAKF,EAAEypB,oBAC1EnpB,EAAK2D,MAAMykB,gBAAgB,QAASpoB,EAAKC,IAAI,MAAOD,GAGtD,IALa,EAKPopB,EAASppB,EAAKC,IAAI,UALX,IAOOmpB,GAPP,IAOb,2BAA4B,KAAjBC,EAAiB,QAC1BrpB,EAAK2D,MAAMykB,gBAAgB,QAASiB,IARzB,gCAYfC,gBAxGuB,SAwGPtpB,GACVA,EAAKkG,IAAI,QAAUlG,EAAKC,IAAI,MAAML,KAAKF,EAAEypB,oBAC3CnpB,EAAK2D,MAAMykB,gBAAgB,QAASpoB,KAKtC2E,EAAM,EAEJqhB,E,WACJ,WAAYhmB,GAAM,UAChBT,KAAKoF,SAAM,EACXpF,KAAKS,UAAO,EACZT,KAAKgqB,WAAQ,EACbhqB,KAAKiqB,YAAS,EACdjqB,KAAKkqB,YAAS,EACdlqB,KAAKyH,cAAW,EAChBzH,KAAKgX,gBAAa,EAClBhX,KAAKmqB,aAAU,EACfnqB,KAAKoqB,UAAO,EACZpqB,KAAK8T,UAAO,EACZ9T,KAAKqqB,cAAW,EAXA,IAadhqB,EACEI,EADFJ,KAGIiqB,EAAS9pB,EAAO4D,MAAM1D,IAAIL,GAEhC,IAAe,MAAViqB,OAAiB,EAASA,EAAO7pB,QAAUA,EAC9C,OAAO6pB,EAGT9pB,EAAO4D,MAAMF,IAAI7D,EAAML,MAEvBA,KAAKoF,IAAMA,IACXpF,KAAKgqB,MAAQ3pB,EACbL,KAAKS,KAAOA,EACZT,KAAKiqB,OAAS,IAAIxhB,IAClBzI,KAAKkqB,QAAS,E,2CA2BP7pB,EAAMoY,EAAMnQ,IACnB,EAAInG,EAAOC,SAAS/B,EAAMoY,EAAMzY,KAAMsI,EAAOtI,KAAKS,Q,oDAGtB8E,GAC5B,IAAMsC,EAAK7H,KAAK+O,sBAAsBxJ,GAItC,OAHAvF,KAAK4H,KAAK,CACRC,OAEK1H,EAAEyF,UAAUiC,K,4CAGCtC,GACpB,OAAOpF,EAAEmF,WAAWtF,KAAKuqB,YAAYhlB,M,oCAGZ,IAErBH,EAFMG,EAAe,uDAAR,OACjBA,EAAOpF,EAAEqqB,aAAajlB,GAAMklB,QAAQ,MAAO,IAAIA,QAAQ,WAAY,IAEnE,IAAItd,EAAI,EAER,GACE/H,EAAMpF,KAAK0qB,aAAanlB,EAAM4H,GAC9BA,UACOnN,KAAK2qB,SAASvlB,IAAQpF,KAAK4qB,WAAWxlB,IAAQpF,KAAK6qB,UAAUzlB,IAAQpF,KAAK8qB,aAAa1lB,IAEhG,IAAMpD,EAAUhC,KAAKsY,mBAGrB,OAFAtW,EAAQgV,WAAW5R,IAAO,EAC1BpD,EAAQooB,KAAKhlB,IAAO,EACbA,I,mCAGIG,EAAM4H,GACjB,IAAItF,EAAKtC,EAET,OADI4H,EAAI,IAAGtF,GAAMsF,GACjB,WAAWtF,K,6CAGUxH,EAAM0qB,GAC3B,IAAMpY,EAAQ,GACdoV,EAAgB1nB,EAAMsS,GACtB,IAAI9K,EAAK8K,EAAMqY,KAAK,KAEpB,OADAnjB,EAAKA,EAAG4iB,QAAQ,KAAM,KAAOM,GAAe,MACrC/qB,KAAKuqB,YAAY1iB,EAAGwK,MAAM,EAAG,O,uDAGLhS,EAAM0qB,GACrC,OAAO5qB,EAAEmF,WAAWtF,KAAKirB,uBAAuB5qB,EAAM0qB,M,+BAG/C1qB,GACP,GAAIF,EAAE+qB,iBAAiB7qB,IAASF,EAAEoQ,QAAQlQ,GACxC,OAAO,EAGT,GAAIF,EAAE4J,aAAa1J,GAAO,CACxB,IAAMmK,EAAUxK,KAAKgK,WAAW3J,EAAKkF,MAErC,OAAIiF,EACKA,EAAQiN,SAERzX,KAAK4qB,WAAWvqB,EAAKkF,MAIhC,OAAO,I,4CAGalF,EAAM8qB,GAC1B,GAAInrB,KAAKyU,SAASpU,GAChB,OAAO,KAEP,IAAMwH,EAAK7H,KAAKorB,iCAAiC/qB,GAEjD,OAAK8qB,EAOEtjB,GANL7H,KAAK4H,KAAK,CACRC,OAEK1H,EAAEyF,UAAUiC,M,iDAOEugB,EAAO5gB,EAAMjC,EAAMsC,GAC5C,GAAa,UAATL,IACe,UAAf4gB,EAAM5gB,OACiB,QAATA,GAAiC,QAAf4gB,EAAM5gB,MAAiC,UAAf4gB,EAAM5gB,MAAmC,WAAf4gB,EAAM5gB,MAAoC,UAAf4gB,EAAM5gB,OAA8B,QAATA,GAA2B,UAATA,KAG5J,MAAMxH,KAAKkP,IAAImc,WAAWxjB,EAApB,iCAAkDtC,EAAlD,KAA2Dwf,a,6BAI9DuG,EAASC,EAASvB,GACvB,IAAMxf,EAAUxK,KAAKgK,WAAWshB,GAEhC,GAAI9gB,EAEF,OADA+gB,EAAUA,GAAWvrB,KAAK+O,sBAAsBuc,GAAS/lB,KAClD,IAAIqiB,EAASxlB,QAAQoI,EAAS8gB,EAASC,GAASC,OAAOxB,K,qCAInDld,EAAKwe,EAASC,EAAS3rB,GAChCkN,EAAIwe,KACNxe,EAAIye,GAAW3rB,EACfkN,EAAIwe,GAAW,Q,6BAKjB,IAAMG,EAAM,IAAIC,OAAO,IACvBnH,QAAQoH,IAAIF,GACZ,IAAIrnB,EAAQpE,KAEZ,EAAG,CACDukB,QAAQoH,IAAI,IAAKvnB,EAAM4lB,MAAMrmB,MAE7B,cAAmBlE,OAAOkI,KAAKvD,EAAMqD,UAArC,eAAgD,CAA3C,IAAMlC,EAAI,KACPiF,EAAUpG,EAAMqD,SAASlC,GAC/Bgf,QAAQoH,IAAI,KAAMpmB,EAAM,CACtBkS,SAAUjN,EAAQiN,SAClBT,WAAYxM,EAAQwM,WACpB4U,WAAYphB,EAAQC,mBAAmBlK,OACvCiH,KAAMgD,EAAQhD,cAGXpD,EAAQA,EAAMzD,QAEvB4jB,QAAQoH,IAAIF,K,8BAGNprB,EAAM8M,EAAG0e,GACf,GAAI1rB,EAAE4J,aAAa1J,GAAO,CACxB,IAAMmK,EAAUxK,KAAKgK,WAAW3J,EAAKkF,MAErC,IAAgB,MAAXiF,OAAkB,EAASA,EAAQiN,WAAajN,EAAQ/J,KAAKqrB,cAAc,SAC9E,OAAOzrB,EAIX,GAAIF,EAAEmL,kBAAkBjL,GACtB,OAAOA,EAGT,GAAIF,EAAE4J,aAAa1J,EAAM,CACvBkF,KAAM,cAEN,OAAOpF,EAAEwE,eAAexE,EAAEkP,iBAAiBlP,EAAEkP,iBAAiBlP,EAAEkP,iBAAiBlP,EAAEmF,WAAW,SAAUnF,EAAEmF,WAAW,cAAenF,EAAEmF,WAAW,UAAWnF,EAAEmF,WAAW,SAAU,CAACjF,IAGtL,IAAI0rB,EACElf,EAAO,CAACxM,GAgBd,OAdU,IAAN8M,EACF4e,EAAa,oBACJ5e,GACTN,EAAKjF,KAAKzH,EAAEyS,eAAezF,IAC3B4e,EAAa,iBAEbA,EAAa,UAGXF,IACFhf,EAAK8G,QAAQ3T,KAAKkP,IAAIC,UAAU4c,IAChCA,EAAa,kBAGR5rB,EAAEwE,eAAe3E,KAAKkP,IAAIC,UAAU4c,GAAalf,K,+BAGjDtH,GACP,QAASvF,KAAKgsB,SAASzmB,K,+BAGhBA,GACP,OAAOvF,KAAKiqB,OAAOvpB,IAAI6E,K,oCAGX9E,GACZT,KAAKiqB,OAAO/lB,IAAIzD,EAAKJ,KAAK4rB,MAAM1mB,KAAM9E,K,0CAGpBA,GAClB,GAAIA,EAAKyU,qBACPlV,KAAKksB,cAAczrB,QACd,GAAIA,EAAK8N,wBACdvO,KAAK6oB,gBAAgB,UAAWpoB,EAAKC,IAAI,MAAOD,QAC3C,GAAIA,EAAKob,wBAAyB,CACvC,IADuC,EACjC9T,EAAetH,EAAKC,IAAI,gBADS,IAGlBqH,GAHkB,IAGvC,2BAAmC,KAAxBC,EAAwB,QACjChI,KAAK6oB,gBAAgBpoB,EAAKJ,KAAKmH,KAAMQ,IAJA,oCAMlC,GAAIvH,EAAKyoB,qBACdlpB,KAAK6oB,gBAAgB,MAAOpoB,QACvB,GAAIA,EAAKgV,sBAAuB,CACrC,IADqC,EAC/ByS,EAAaznB,EAAKC,IAAI,cADS,IAGbwnB,GAHa,IAGrC,2BAAoC,KAAzBiE,EAAyB,QAClCnsB,KAAK6oB,gBAAgB,SAAUsD,IAJI,oCAMhC,GAAI1rB,EAAKsW,sBAAuB,CACrC,IAAM/O,EAASvH,EAAKC,IAAI,gBAEpBsH,EAAOkhB,sBAAwBlhB,EAAOuG,yBAA2BvG,EAAO6T,0BAC1E7b,KAAK+oB,oBAAoB/gB,QAG3BhI,KAAK6oB,gBAAgB,UAAWpoB,K,2CAKlC,OAAON,EAAEisB,gBAAgB,OAAQjsB,EAAEyS,eAAe,IAAI,K,gDAG9BnS,GAGxB,IAFA,IAAM+gB,EAAM/gB,EAAKiH,wBAEjB,MAAmBjI,OAAOkI,KAAK6Z,GAA/B,eAAqC,CAAhC,IAAMjc,EAAI,KACPiF,EAAUxK,KAAKgK,WAAWzE,GAC5BiF,GAASA,EAAQ6hB,SAAS5rB,M,sCAIlB+G,EAAM/G,GAA0B,IAApB6rB,EAAoB,uDAAN7rB,EACxC,IAAK+G,EAAM,MAAM,IAAI1D,eAAe,aAEpC,GAAIrD,EAAKob,wBAAT,CACE,IADgC,EAC1B0Q,EAAc9rB,EAAKC,IAAI,gBADG,IAGX6rB,GAHW,IAGhC,2BAAkC,KAAvBvkB,EAAuB,QAChChI,KAAK6oB,gBAAgBrhB,EAAMQ,IAJG,oCAalC,IAHA,IAAMrH,EAASX,KAAKsY,mBACdkJ,EAAM/gB,EAAK2gB,4BAA2B,GAE5C,MAAmB3hB,OAAOkI,KAAK6Z,GAA/B,eAAqC,CAAhC,IAAMjc,EAAI,KACb5E,EAAOqW,WAAWzR,IAAQ,EADS,UAGlBic,EAAIjc,IAHc,IAGnC,2BAA4B,KAAjBsC,EAAiB,QACpBugB,EAAQpoB,KAAKwsB,cAAcjnB,GAEjC,GAAI6iB,EAAO,CACT,GAAIA,EAAM9iB,aAAeuC,EAAI,SAC7B7H,KAAKysB,2BAA2BrE,EAAO5gB,EAAMjC,EAAMsC,GAGjDugB,EACFpoB,KAAK0sB,0BAA0BJ,GAE/BtsB,KAAKyH,SAASlC,GAAQ,IAAIsiB,EAASzlB,QAAQ,CACzCkD,WAAYuC,EACZzD,MAAOpE,KACPS,KAAM6rB,EACN9kB,KAAMA,KAlBuB,kC,gCAyB7BnH,GACRL,KAAKmqB,QAAQ9pB,EAAKkF,MAAQlF,I,6BAGrBkF,GACL,IAAInB,EAAQpE,KAEZ,GACE,GAAIoE,EAAMgmB,KAAK7kB,GAAO,OAAO,QACtBnB,EAAQA,EAAMzD,QAEvB,OAAO,I,gCAGC4E,GACR,IAAInB,EAAQpE,KAEZ,GACE,GAAIoE,EAAM+lB,QAAQ5kB,GAAO,OAAO,QACzBnB,EAAQA,EAAMzD,QAEvB,OAAO,I,mCAGI4E,GACX,QAASvF,KAAKsY,mBAAmBtB,WAAWzR,K,6BAGvClF,EAAMssB,GACX,GAAIxsB,EAAE4J,aAAa1J,GAAO,CACxB,IAAMmK,EAAUxK,KAAKgK,WAAW3J,EAAKkF,MACrC,QAAKiF,KACDmiB,GAAsBniB,EAAQiN,UAE7B,GAAItX,EAAEiL,QAAQ/K,GACnB,QAAIA,EAAK0S,aAAe/S,KAAKsnB,OAAOjnB,EAAK0S,WAAY4Z,KAI9C3sB,KAAKsnB,OAAOjnB,EAAK4B,KAAM0qB,GACzB,GAAIxsB,EAAEysB,YAAYvsB,GAAO,WACTA,EAAK4B,MADI,IAC9B,2BAAgC,KAArByR,EAAqB,QAC9B,IAAK1T,KAAKsnB,OAAO5T,EAAQiZ,GAAgB,OAAO,GAFpB,8BAK9B,OAAO,EACF,GAAIxsB,EAAE4b,SAAS1b,GACpB,OAAOL,KAAKsnB,OAAOjnB,EAAK6L,KAAMygB,IAAkB3sB,KAAKsnB,OAAOjnB,EAAK+L,MAAOugB,GACnE,GAAIxsB,EAAEmL,kBAAkBjL,GAAO,WACjBA,EAAKwsB,UADY,IACpC,2BAAkC,KAAvBzf,EAAuB,QAChC,IAAKpN,KAAKsnB,OAAOla,EAAMuf,GAAgB,OAAO,GAFZ,8BAKpC,OAAO,EACF,GAAIxsB,EAAEuL,mBAAmBrL,GAAO,WAClBA,EAAKgoB,YADa,IACrC,2BAAoC,KAAzBzc,EAAyB,QAClC,IAAK5L,KAAKsnB,OAAO1b,EAAM+gB,GAAgB,OAAO,GAFX,8BAKrC,OAAO,EACF,GAAIxsB,EAAEuN,SAASrN,GACpB,QAAIA,EAAK0L,WAAa/L,KAAKsnB,OAAOjnB,EAAKS,IAAK6rB,MAC1B,QAAdtsB,EAAKmH,MAAgC,QAAdnH,EAAKmH,MAE3B,GAAIrH,EAAEsN,WAAWpN,GACtB,QAAIA,EAAK0L,WAAa/L,KAAKsnB,OAAOjnB,EAAKS,IAAK6rB,KACrC3sB,KAAKsnB,OAAOjnB,EAAKT,MAAO+sB,GAC1B,GAAIxsB,EAAE4K,kBAAkB1K,GAC7B,OAAOL,KAAKsnB,OAAOjnB,EAAK6K,SAAUyhB,GAC7B,GAAIxsB,EAAEwJ,2BAA2BtJ,GACtC,OAAOF,EAAEmU,eAAejU,EAAKysB,IAAK,gBAAkB9sB,KAAK4qB,WAAW,UAAU,IAAS5qB,KAAKsnB,OAAOjnB,EAAK4J,MAAO0iB,GAC1G,GAAIxsB,EAAEqJ,kBAAkBnJ,GAAO,WACXA,EAAKyb,aADM,IACpC,2BAA2C,KAAhC5Z,EAAgC,QACzC,IAAKlC,KAAKsnB,OAAOplB,EAAYyqB,GAAgB,OAAO,GAFlB,8BAKpC,OAAO,EAEP,OAAOxsB,EAAE4sB,UAAU1sB,K,8BAIfS,EAAKoI,GACX,OAAOlJ,KAAK8T,KAAKhT,GAAOoI,I,8BAGlBpI,GACN,IAAIsD,EAAQpE,KAEZ,EAAG,CACD,IAAM8T,EAAO1P,EAAM0P,KAAKhT,GACxB,GAAY,MAARgT,EAAc,OAAOA,QAClB1P,EAAQA,EAAMzD,U,iCAGdG,GACT,IAAIsD,EAAQpE,KAEZ,EAAG,CAEW,MADCoE,EAAM0P,KAAKhT,KACNsD,EAAM0P,KAAKhT,GAAO,YAC7BsD,EAAQA,EAAMzD,U,6BAIlBX,KAAKkqB,SACRlqB,KAAKkqB,QAAS,EACdlqB,KAAKgtB,W,8BAKP,IAAMvsB,EAAOT,KAAKS,KAClBT,KAAKgX,WAAavX,OAAOgiB,OAAO,MAChCzhB,KAAKyH,SAAWhI,OAAOgiB,OAAO,MAC9BzhB,KAAKmqB,QAAU1qB,OAAOgiB,OAAO,MAC7BzhB,KAAKoqB,KAAO3qB,OAAOgiB,OAAO,MAC1BzhB,KAAK8T,KAAOrU,OAAOgiB,OAAO,MAC1B,IAAMwL,EAAgBjtB,KAAKsY,mBAC3B,IAAI2U,EAAc5C,SAAlB,CACA,IAAM/hB,EAAQ,CACZ0O,WAAY,GACZvM,mBAAoB,GACpB+e,YAAa,IAIf,GAFAxpB,KAAKqqB,UAAW,EAEE,YAAd5pB,EAAKkD,MAAsB+kB,EAAiB/E,UAAW,WACrC+E,EAAiB5E,OADoB,IACzD,2BAA4C,EAC1C1K,EAD0C,SACpC3Y,EAAM6H,IAF2C,8BAKzD,IAAM4kB,EAAexE,EAAiBjoB,EAAKkD,MAE3C,GAAIupB,EAAc,WACIA,EAAapJ,OADjB,IAChB,2BAAwC,EACtC1K,EADsC,SAChC3Y,EAAM6H,IAFE,gCAOpB7H,EAAKmE,SAAS8jB,EAAkBpgB,GAChCtI,KAAKqqB,UAAW,EA/BV,UAiCa/hB,EAAMkhB,aAjCnB,IAiCN,2BAAsC,CAGpC,IAHoC,IAA3B/oB,EAA2B,QAC9B+gB,EAAM/gB,EAAKiH,wBAEjB,MAAmBjI,OAAOkI,KAAK6Z,GAA/B,eAAqC,CAAhC,IAAMjc,EAAI,KACT9E,EAAK2D,MAAM4F,WAAWzE,IAC1B0nB,EAAcE,UAAU3L,EAAIjc,IAG9B9E,EAAK2D,MAAMsoB,0BAA0BjsB,IAzCjC,wCA4CY6H,EAAM0O,YA5ClB,IA4CN,2BAAoC,KAAzBoW,EAAyB,QAC5B5iB,EAAU4iB,EAAIhpB,MAAM4F,WAAWojB,EAAI/sB,KAAKkF,MAE1CiF,EACFA,EAAQ2e,UAAUiE,GAElBH,EAAcE,UAAUC,EAAI/sB,OAlD1B,wCAsDaiI,EAAMmC,oBAtDnB,IAsDN,2BAA6C,KAAlChK,EAAkC,QAC3CA,EAAK2D,MAAMsoB,0BAA0BjsB,IAvDjC,kC,2BA2DHgY,GACH,IAAIhY,EAAOT,KAAKS,KAEXA,EAAKqN,oBAAuBrN,EAAKiC,cACpCjC,EAAOT,KAAKspB,iBAAiB7oB,MAG3BA,EAAKkf,sBACPlf,GAAQT,KAAKsE,qBAAuBtE,KAAKsY,oBAAoB7X,OAG3DA,EAAK0E,UAAY1E,EAAKif,iBAAmBjf,EAAK0K,gBAChD1K,EAAKmN,cACLnN,EAAOA,EAAKC,IAAI,SAGlB,IAAM2sB,EAAS5U,EAAK4U,OACd7lB,EAAOiR,EAAKjR,MAAQ,MACpB8lB,EAAiC,MAApB7U,EAAKmG,YAAsB,EAAInG,EAAKmG,YACjD2O,EAAU,eAAH,OAAkB/lB,EAAlB,YAA0B8lB,GACnCE,GAAcH,GAAU5sB,EAAK4E,QAAQkoB,GAEzC,IAAKC,EAAY,CACf,IAAMxlB,EAAS7H,EAAE+e,oBAAoB1X,EAAM,IAC3CQ,EAAO4W,YAAc0O,EAFN,MAGA7sB,EAAKwO,iBAAiB,OAAQ,CAACjH,IAA7CwlB,EAHc,UAIVH,GAAQ5sB,EAAKoF,QAAQ0nB,EAASC,GAGrC,IAAMxO,EAAa7e,EAAE8e,mBAAmBxG,EAAK5Q,GAAI4Q,EAAKxQ,MACtDulB,EAAWntB,KAAK0H,aAAaH,KAAKoX,GAClChf,KAAK6oB,gBAAgBrhB,EAAMgmB,EAAW9sB,IAAI,gBAAgB8Z,S,yCAI1D,IAAIpW,EAAQpE,KAEZ,GACE,GAAIoE,EAAM3D,KAAKiC,YACb,OAAO0B,QAEFA,EAAQA,EAAMzD,QAEvB,MAAM,IAAI6B,MAAM,6B,0CAIhB,IAAI4B,EAAQpE,KAEZ,GACE,GAAIoE,EAAM3D,KAAKgtB,mBACb,OAAOrpB,QAEFA,EAAQA,EAAMzD,QAEvB,OAAO,O,uCAIP,IAAIyD,EAAQpE,KAEZ,GACE,GAAIoE,EAAM3D,KAAKitB,gBACb,OAAOtpB,QAEFA,EAAQA,EAAMzD,QAEvB,MAAM,IAAI6B,MAAM,kF,uCAIhB,IAAMgf,EAAM/hB,OAAOgiB,OAAO,MACtBrd,EAAQpE,KAEZ,EAAG,CACD,cAAkBP,OAAOkI,KAAKvD,EAAMqD,UAApC,eAA+C,CAA1C,IAAM3G,EAAG,KACRA,KAAO0gB,KAAQ,IACjBA,EAAI1gB,GAAOsD,EAAMqD,SAAS3G,IAI9BsD,EAAQA,EAAMzD,aACPyD,GAET,OAAOod,I,6CAGsB,IAC7B,IAAMA,EAAM/hB,OAAOgiB,OAAO,MADG,mBAAPkM,EAAO,yBAAPA,EAAO,gBAG7B,cAAmBA,EAAnB,eAA0B,CAArB,IAAMnmB,EAAI,KACTpD,EAAQpE,KAEZ,EAAG,CACD,cAAmBP,OAAOkI,KAAKvD,EAAMqD,UAArC,eAAgD,CAA3C,IAAMlC,EAAI,KACPiF,EAAUpG,EAAMqD,SAASlC,GAC3BiF,EAAQhD,OAASA,IAAMga,EAAIjc,GAAQiF,GAGzCpG,EAAQA,EAAMzD,aACPyD,GAGX,OAAOod,I,8CAGejc,EAAMlF,GAC5B,OAAOL,KAAK4tB,qBAAqBroB,KAAUlF,I,iCAGlCkF,GACT,IACIsoB,EADAzpB,EAAQpE,KAGZ,EAAG,CACD,IAGM8tB,EAHAtjB,EAAUpG,EAAMooB,cAAcjnB,GAEpC,GAAIiF,EAGF,KAAuC,OAAjCsjB,EAAgBD,QAAwB,EAASC,EAAchR,cAAiC,UAAjBtS,EAAQhD,KAC3F,OAAOgD,EAIXqjB,EAAezpB,EAAM3D,WACd2D,EAAQA,EAAMzD,U,oCAGX4E,GACZ,OAAOvF,KAAKyH,SAASlC,K,2CAGFA,GACnB,IAAIwoB,EAEJ,OAAqD,OAA7CA,EAAmB/tB,KAAKgK,WAAWzE,SAAiB,EAASwoB,EAAiBzoB,a,8CAGhEC,GACtB,IAAMiF,EAAUxK,KAAKyH,SAASlC,GAC9B,OAAkB,MAAXiF,OAAkB,EAASA,EAAQlF,a,oCAG9BC,GACZ,QAASvF,KAAKwsB,cAAcjnB,K,iCAGnBA,EAAMyoB,GACf,QAAKzoB,MACDvF,KAAKse,cAAc/Y,OACnBvF,KAAKiuB,iBAAiB1oB,EAAMyoB,OAC5BhuB,KAAKkuB,OAAO3oB,OACXyoB,IAAavH,EAAM0D,QAAQ/U,SAAS7P,OACpCyoB,IAAavH,EAAM0H,iBAAiB/Y,SAAS7P,U,uCAInCA,EAAMyoB,GACrB,IAAII,EAEJ,OAAuC,OAA/BA,EAAepuB,KAAKW,aAAkB,EAASytB,EAAaxD,WAAWrlB,EAAMyoB,K,oCAGzEzoB,EAAMnB,GAClB,IAAMiqB,EAAOruB,KAAKgK,WAAWzE,GAEzB8oB,IACFA,EAAKjqB,MAAMkqB,iBAAiB/oB,GAC5B8oB,EAAKjqB,MAAQA,EACbA,EAAMqD,SAASlC,GAAQ8oB,K,uCAIV9oB,UACRvF,KAAKyH,SAASlC,K,oCAGTA,GACZ,IAAIgpB,EAE2C,OAA9CA,EAAoBvuB,KAAKgK,WAAWzE,KAA0BgpB,EAAkBnqB,MAAMkqB,iBAAiB/oB,GACxG,IAAInB,EAAQpE,KAEZ,GACMoE,EAAMgmB,KAAK7kB,KACbnB,EAAMgmB,KAAK7kB,IAAQ,SAEdnB,EAAQA,EAAMzD,U,6BAzoBvB,IAAI6tB,EAEA7tB,EACAF,EAAOT,KAAKS,KAEhB,EAAG,CACD,IAAMguB,EAAqB,QAAbhuB,EAAKK,IACnBL,EAAOA,EAAKyC,WACRurB,GAAShuB,EAAKiN,aAAYjN,EAAOA,EAAKyC,YACtCzC,GAAQA,EAAKymB,YAAWvmB,EAASF,SAC9BA,IAASE,GAElB,OAA6B,OAArB6tB,EAAU7tB,QAAkB,EAAS6tB,EAAQpqB,Q,kCAIrD,OAAOpE,KAAKS,KAAKE,S,0BAIjB,OAAOX,KAAKS,KAAKyO,Q,KA0nBrBvP,EAAQyC,QAAUqkB,EAClBA,EAAM0D,QAAU1qB,OAAOkI,KAAKmgB,EAAS1lB,QAAQssB,SAC7CjI,EAAM0H,iBAAmB,CAAC,YAAa,YAAa,WAAY,Q,qDCt8BhE1uB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,aAAU,E,IAEZusB,E,WACJ,cAKG,IAJDrpB,EAIC,EAJDA,WACAlB,EAGC,EAHDA,MACA3D,EAEC,EAFDA,KACA+G,EACC,EADDA,KACC,UACDxH,KAAKsF,gBAAa,EAClBtF,KAAKoE,WAAQ,EACbpE,KAAKS,UAAO,EACZT,KAAKwH,UAAO,EACZxH,KAAKyK,mBAAqB,GAC1BzK,KAAKyX,UAAW,EAChBzX,KAAKkX,eAAiB,GACtBlX,KAAK4uB,YAAa,EAClB5uB,KAAKgX,WAAa,EAClBhX,KAAKsF,WAAaA,EAClBtF,KAAKoE,MAAQA,EACbpE,KAAKS,KAAOA,EACZT,KAAKwH,KAAOA,EACZxH,KAAK6uB,a,+CAIL7uB,KAAK6uB,aACL7uB,KAAK8uB,iBAAkB,I,+BAGhBlvB,GACHI,KAAK8uB,kBACT9uB,KAAK2K,UAAW,EAChB3K,KAAKJ,MAAQA,K,mCAIbI,KAAK8uB,iBAAkB,EACvB9uB,KAAK2K,UAAW,EAChB3K,KAAKJ,MAAQ,O,+BAGNa,GACPT,KAAKyX,UAAW,GAE+B,IAA3CzX,KAAKyK,mBAAmBkC,QAAQlM,IAIpCT,KAAKyK,mBAAmB7C,KAAKnH,K,gCAGrBA,IACmC,IAAvCT,KAAKkX,eAAevK,QAAQlM,KAIhCT,KAAK4uB,YAAa,EAClB5uB,KAAKgX,aACLhX,KAAKkX,eAAetP,KAAKnH,M,oCAIzBT,KAAKgX,aACLhX,KAAK4uB,aAAe5uB,KAAKgX,e,KAK7BrX,EAAQyC,QAAUusB,G,4CCxElBlvB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETH,OAAOC,eAAeC,EAAS,WAAY,CACzCovB,YAAY,EACZruB,IAAK,WACH,OAAOsuB,EAAM5sB,WAGjB3C,OAAOC,eAAeC,EAAS,QAAS,CACtCovB,YAAY,EACZruB,IAAK,WACH,OAAOuuB,EAAO7sB,WAGlB3C,OAAOC,eAAeC,EAAS,MAAO,CACpCovB,YAAY,EACZruB,IAAK,WACH,OAAOwuB,EAAK9sB,WAGhBzC,EAAQsjB,SAAWtjB,EAAQyC,aAAU,EAErC,IAAI+sB,EAAW7oB,EAAuBD,EAAQ,MAE1C4c,EAAW9b,EAAwBd,EAAQ,OAE/C1G,EAAQsjB,SAAWA,EAEnB,IAAI9iB,EAAIgH,EAAwBd,EAAQ,KAEpCI,EAAQU,EAAwBd,EAAQ,MAExC2oB,EAAQ1oB,EAAuBD,EAAQ,KAEvC4oB,EAAS3oB,EAAuBD,EAAQ,MAExC6oB,EAAO5oB,EAAuBD,EAAQ,OAE1C,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASU,EAAwBZ,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAyE,OAA7D8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAkBA,EAE9tB,SAASN,EAAuBC,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAEvF,SAAS3B,EAASjE,GAA6C,IAArC8X,EAAqC,uDAA9B,GAAIrU,EAA0B,uCAAnBkE,EAAmB,uCAAZpF,EAAY,uCAC7D,GAAKvC,EAAL,CAEA,IAAK8X,EAAKmB,UAAYxV,GACA,YAAhBzD,EAAOgD,MAAsC,SAAhBhD,EAAOgD,KACtC,MAAM,IAAInB,MAAM,0EAA4E,2CAA5E,OAAuH7B,EAAOgD,KAA9H,kBAAqJ,iCAIpKxD,EAAEyW,aAAajW,EAAOgD,QAI3Bsf,EAASH,QAAQrK,GACjB7T,EAASvE,KAAKM,EAAQ8X,EAAMrU,EAAOkE,EAAOpF,KAG5C,IAAIksB,EAAWxqB,EA+Bf,SAASyqB,EAAkB5uB,EAAM6H,GAC3B7H,EAAKJ,KAAKsD,OAAS2E,EAAM3E,OAC3B2E,EAAM3B,KAAM,EACZlG,EAAKgZ,QAjCT9Z,EAAQyC,QAAUgtB,EAClBxqB,EAASqe,SAAWA,EACpBre,EAASme,OAASE,EAASF,OAC3Bne,EAASke,QAAUG,EAASH,QAE5Ble,EAAS0qB,MAAQ,SAAUjvB,EAAMyjB,GAC/B,OAAO3jB,EAAEovB,aAAalvB,EAAMyjB,IAG9Blf,EAASvE,KAAO,SAAUA,EAAMoY,EAAMrU,EAAOkE,EAAOpF,EAAYqW,GAC9D,IAAM5R,EAAOxH,EAAEyW,aAAavW,EAAKsD,MACjC,GAAKgE,EAAL,CACA,IAHwE,EAGlE8E,EAAU,IAAI0iB,EAAS/sB,QAAQgC,EAAOqU,EAAMnQ,EAAOpF,GAHe,IAKtDyE,GALsD,IAKxE,2BAAwB,KAAb7G,EAAa,QACtB,KAAIyY,IAAYA,EAASzY,KACrB2L,EAAQ2M,MAAM/Y,EAAMS,GAAM,QAPwC,iCAW1E8D,EAAS4qB,UAAY,SAAUnvB,EAAMoY,GACnCtY,EAAEkC,iBAAiBhC,EAAMoY,GACzBhS,EAAMhG,KAAKG,OAAOP,IAGpBuE,EAASvC,iBAAmB,SAAUotB,EAAMhX,GAE1C,OADAtY,EAAEovB,aAAaE,EAAM7qB,EAAS4qB,UAAW/W,GAClCgX,GAUT7qB,EAASoB,QAAU,SAAUypB,EAAM9rB,EAAM+rB,GACvC,GAAqB,MAAjBA,OAAwB,EAASA,EAActa,SAASqa,EAAK9rB,MAAO,OAAO,EAC/E,GAAI8rB,EAAK9rB,OAASA,EAAM,OAAO,EAC/B,IAAM2E,EAAQ,CACZ3B,KAAK,EACLhD,KAAMA,GAOR,OALAiB,EAAS6qB,EAAM,CACb7V,SAAS,EACTV,SAAUwW,EACV5L,MAAOuL,GACN,KAAM/mB,GACFA,EAAM3B,KAGf/B,EAAS6B,MAAQA,G,6DCnHjBhH,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,aAAU,EAElB,IAQgCmE,EAR5ByoB,GAQ4BzoB,EARGF,EAAQ,MAQUE,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GANnFpG,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAMlL,IAEMkpB,E,WACJ,WAAYvrB,EAAOqU,EAAMnQ,EAAOpF,GAAY,UAC1ClD,KAAK6c,MAAQ,KACb7c,KAAK4vB,cAAgB,KACrB5vB,KAAKkD,WAAaA,EAClBlD,KAAKoE,MAAQA,EACbpE,KAAKsI,MAAQA,EACbtI,KAAKyY,KAAOA,E,8CAGFpY,GACV,IAAMoY,EAAOzY,KAAKyY,KAClB,GAAIA,EAAKqL,OAASrL,EAAK2M,KAAM,OAAO,EACpC,GAAI3M,EAAKpY,EAAKsD,MAAO,OAAO,EAC5B,IAAMgE,EAAOxH,EAAEyW,aAAavW,EAAKsD,MACjC,KAAc,MAARgE,OAAe,EAASA,EAAKpH,QAAS,OAAO,EALnC,UAOEoH,GAPF,IAOhB,2BAAwB,CACtB,GAAItH,EADkB,SACP,OAAO,GARR,8BAWhB,OAAO,I,6BAGFA,EAAMkG,EAAKzF,EAAKiN,GACrB,OAAOihB,EAAM5sB,QAAQ1B,IAAI,CACvBwC,WAAYlD,KAAKkD,WACjBvC,OAAQN,EACRQ,UAAW0F,EACXzF,IAAKA,EACLiN,c,iCAIOtN,EAAMovB,GACf,GAAI7vB,KAAK8vB,KACP,MAAM,IAAIttB,MAAM,2BAGdxC,KAAK6c,QACHgT,EACF7vB,KAAK6c,MAAMjV,KAAKnH,GAEhBT,KAAK4vB,cAAchoB,KAAKnH,M,oCAKhBI,EAAWF,EAAQoN,GAC/B,GAAyB,IAArBlN,EAAUN,OAAc,OAAO,EAGnC,IAFA,IAAMsc,EAAQ,GAEL/b,EAAM,EAAGA,EAAMD,EAAUN,OAAQO,IAAO,CAC/C,IAAMT,EAAOQ,EAAUC,GAEnBT,GAAQL,KAAK+vB,YAAY1vB,IAC3Bwc,EAAMjV,KAAK5H,KAAKyhB,OAAO9gB,EAAQE,EAAWC,EAAKiN,IAInD,OAAO/N,KAAKgwB,WAAWnT,K,kCAGbxc,EAAMS,GAChB,QAAId,KAAK+vB,YAAY1vB,EAAKS,KACjBd,KAAKgwB,WAAW,CAAChwB,KAAKyhB,OAAOphB,EAAMA,EAAMS,O,iCAMzC+b,GACT7c,KAAK6c,MAAQA,EACb7c,KAAK4vB,cAAgB,GACrB,IAHgB,EAGVK,EAAU,IAAIhd,QAChBwG,GAAO,EAJK,IAMGoD,GANH,IAMhB,2BAA0B,KAAfpc,EAAe,QAOxB,GANAA,EAAKR,SAEwB,IAAzBQ,EAAK8Z,SAASha,QAAgBE,EAAK8Z,SAAS9Z,EAAK8Z,SAASha,OAAS,KAAOP,MAC5ES,EAAKga,YAAYza,MAGF,OAAbS,EAAKK,IAAT,CAtFUovB,MA+Ec,IActB7vB,EACEI,EADFJ,KAEF,IAAI4vB,EAAQtpB,IAAItG,GAAhB,CAGA,GAFIA,GAAM4vB,EAAQ/c,IAAI7S,GAElBI,EAAK2Y,QAAS,CAChBK,GAAO,EACP,MAGF,GAAIzZ,KAAK4vB,cAAcrvB,SACrBkZ,EAAOzZ,KAAKgwB,WAAWhwB,KAAK4vB,eAC5B5vB,KAAK4vB,cAAgB,GACrB5vB,KAAK6c,MAAQA,EACTpD,GAAM,SAlCE,wCAsCGoD,GAtCH,IAsChB,2BAA0B,SACnBvC,cAvCS,8BA2ChB,OADAta,KAAK6c,MAAQ,KACNpD,I,4BAGHpZ,EAAMS,GACV,IAAMhB,EAAQO,EAAKS,GACnB,QAAKhB,IAED6C,MAAMC,QAAQ9C,GACTE,KAAKmwB,cAAcrwB,EAAOO,EAAMS,GAEhCd,KAAKowB,YAAY/vB,EAAMS,Q,KAMpCnB,EAAQyC,QAAUutB,G,6DCnJlBlwB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,aAAU,EAEHkE,EAAuBD,EAAQ,MAA9C,IAEIgqB,EAAgC/pB,EAAuBD,EAAQ,MAE/DlG,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAIlL,SAASH,EAAuBC,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAEvF,IAAM+pB,EAAgB,CACpBlc,qBADoB,WAGjB9L,GAAO,IADRjI,EACQ,EADRA,KAEIA,EAAKkF,OAAS+C,EAAMgjB,UACtBjrB,EAAKkF,KAAO+C,EAAMijB,UAItB9E,MAToB,SASdhmB,EAAM6H,GACL7H,EAAK2D,MAAM8Z,wBAAwB5V,EAAMgjB,QAAShjB,EAAMkC,QAAQlF,aAuGzE,SAAqC7E,GACnC,IAAKA,EAAKiN,aAAejN,EAAKJ,KAAK0L,SAEjC,YADAtL,EAAK6G,OAIP,IANyC,EAMnCK,EAAOxH,EAAEyW,aAAanW,EAAKkD,MANQ,IAQvBgE,GARuB,IAQzC,2BAAwB,KAAb7G,EAAa,QACV,QAARA,GAAeL,EAAK+Y,QAAQ1Y,IATO,+BAtGrCyvB,CAA4B9vB,IAIhC,sDAfoB,SAekCA,EAAM6H,GAC1D,IAAI7H,EAAKob,wBAAT,CACA,IAAM2F,EAAM/gB,EAAK2gB,6BAEjB,IAAK,IAAM7b,KAAQic,EACbjc,IAAS+C,EAAMgjB,UAAS9J,EAAIjc,GAAMA,KAAO+C,EAAMijB,YAMnDiF,E,WACJ,WAAYhmB,EAAS8gB,EAASC,GAAS,UACrCvrB,KAAKurB,QAAUA,EACfvrB,KAAKsrB,QAAUA,EACftrB,KAAKwK,QAAUA,E,oEAGiBimB,GAChC,IAAMC,EAAoBD,EAAavtB,WAElCwtB,EAAkB3Z,wBAInB2Z,EAAkBvtB,+BAAiCutB,EAAkBhwB,IAAI,eAAeL,KAAKwH,KAIjG,EAAIwoB,EAA8BjuB,SAASsuB,M,+DAGJjwB,M,8DASDA,M,6BAWjCupB,GAAO,WAEVxf,EAGExK,KAHFwK,QACA8gB,EAEEtrB,KAFFsrB,QACAC,EACEvrB,KADFurB,QAGAnnB,EAEEoG,EAFFpG,MAGIqsB,EADFjmB,EADF/J,KAEwB0W,MAAK,SAAA1W,GAAI,OAAIA,EAAK2b,iBAAmB3b,EAAK6N,wBAA0B7N,EAAKkwB,uBAE/FF,IACiBA,EAAarP,6BAEjBkK,KAAa9gB,EAAQlF,YAClCtF,KAAK4wB,kCAAkCH,IAI3C,IAAMI,EAAkB7G,GAAS5lB,EAAM4lB,MAE2B,qBAA1C,MAAnB6G,OAA0B,EAASA,EAAgBltB,MACtDktB,EAAgBjR,MAAMlP,SAAQ,SAAAogB,GAC5B1sB,EAAMQ,SAASksB,EAAGR,EAAe,MAGnClsB,EAAMQ,SAASisB,EAAiBP,EAAetwB,MAG5CgqB,IACH5lB,EAAMkqB,iBAAiBhD,GACvBlnB,EAAMqD,SAAS8jB,GAAW/gB,EAC1BxK,KAAKwK,QAAQlF,WAAWC,KAAOgmB,GAG7BkF,IACFzwB,KAAK+wB,yCAAyCN,GAC9CzwB,KAAKgxB,wCAAwCP,Q,KAMnD9wB,EAAQyC,QAAUouB,G,4DChIlB/wB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,QAAUzC,EAAQ+Z,YAAc/Z,EAAQga,YAAcha,EAAQ8b,aAAU,EAEhF,IAAIiI,EAAevc,EAAwBd,EAAQ,MAE/C4qB,EAAS3qB,EAAuBD,EAAQ,MAExClE,EAASmE,EAAuBD,EAAQ,KAExC4oB,EAAS3oB,EAAuBD,EAAQ,MAExClG,EAAIgH,EAAwBd,EAAQ,KAEpC7F,EAAS6F,EAAQ,KAEjB6qB,EAAa5qB,EAAuBD,EAAQ,MAE5C8qB,EAAoBhqB,EAAwBd,EAAQ,MAEpD+qB,EAAqBjqB,EAAwBd,EAAQ,MAErDgrB,EAAuBlqB,EAAwBd,EAAQ,MAEvDirB,EAAsBnqB,EAAwBd,EAAQ,OAEtDkrB,EAAsBpqB,EAAwBd,EAAQ,OAEtDmrB,EAAyBrqB,EAAwBd,EAAQ,OAEzDorB,EAAmBtqB,EAAwBd,EAAQ,OAEnDqrB,EAAmBvqB,EAAwBd,EAAQ,OAEnDsrB,EAAwBxqB,EAAwBd,EAAQ,OAExDurB,EAAkBzqB,EAAwBd,EAAQ,OAElDwrB,EAAoB1qB,EAAwBd,EAAQ,OAExD,SAASC,EAAuBC,GAAO,OAAOA,GAAOA,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAEvF,SAASG,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASU,EAAwBZ,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAyE,OAA7D8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAkBA,EAE9tB,IAAM3C,GAAQ,EAAIgtB,EAAO7uB,SAAS,SAElCzC,EAAQ8b,QADQ,EAGhB9b,EAAQga,YADY,EAGpBha,EAAQ+Z,YADY,E,IAGdoY,E,WACJ,WAAY5iB,EAAKvO,GAAQ,UACvBX,KAAKua,SAAW,GAChBva,KAAKsI,MAAQ,KACbtI,KAAKyY,KAAO,KACZzY,KAAK8Y,eAAiB,EACtB9Y,KAAKuZ,SAAW,KAChBvZ,KAAKkD,WAAa,KAClBlD,KAAKa,UAAY,KACjBb,KAAK+N,QAAU,KACf/N,KAAKc,IAAM,KACXd,KAAKK,KAAO,KACZL,KAAK2D,KAAO,KACZ3D,KAAKW,OAASA,EACdX,KAAKkP,IAAMA,EACXlP,KAAK8T,KAAO,KACZ9T,KAAKyM,QAAU,KACfzM,KAAKoE,MAAQ,K,2CAwCNA,GACP,OAAOpE,KAAKknB,UAAY,IAAI+H,EAAO7sB,QAAQpC,MAAQoE,I,8BAG7CtD,EAAKoI,GAKX,OAJiB,MAAblJ,KAAK8T,OACP9T,KAAK8T,KAAOrU,OAAOgiB,OAAO,OAGrBzhB,KAAK8T,KAAKhT,GAAOoI,I,8BAGlBpI,EAAKixB,GACM,MAAb/xB,KAAK8T,OACP9T,KAAK8T,KAAOrU,OAAOgiB,OAAO,OAG5B,IAAIvY,EAAMlJ,KAAK8T,KAAKhT,GAEpB,YADY6H,IAARO,QAA6BP,IAARopB,IAAmB7oB,EAAMlJ,KAAK8T,KAAKhT,GAAOixB,GAC5D7oB,I,0CAGWiU,GAA0B,IAArB3a,EAAqB,uDAAbwvB,YAC/B,OAAOhyB,KAAKkP,IAAImc,WAAWrrB,KAAKK,KAAM8c,EAAK3a,K,+BAGpC6gB,EAAS/a,IAChB,EAAInG,EAAOC,SAASpC,KAAKK,KAAMgjB,EAASrjB,KAAKoE,MAAOkE,EAAOtI,Q,0BAGzDc,EAAKT,GACPF,EAAE6D,SAAShE,KAAKK,KAAMS,EAAKT,GAC3BL,KAAKK,KAAKS,GAAOT,I,wCAIjB,IAAMsS,EAAQ,GACVlS,EAAOT,KAEX,EAAG,CACD,IAAIc,EAAML,EAAKK,IACXL,EAAKsD,SAAQjD,EAAM,GAAH,OAAML,EAAKsN,QAAX,YAAsBjN,EAAtB,MACpB6R,EAAMgB,QAAQ7S,SACPL,EAAOA,EAAKyC,YAErB,OAAOyP,EAAMqY,KAAK,O,4BAGdvpB,GACCwC,EAAMguB,SACXhuB,EAAM,GAAD,OAAIjE,KAAKkyB,kBAAT,YAA8BlyB,KAAK2D,KAAnC,aAA4ClC,M,iCAIjD,OAAO,EAAIyvB,EAAW9uB,SAASpC,KAAKK,MAAM0B,O,6BAI1C,QAAS/B,KAAK+N,S,aAGLhK,GACJA,IACH/D,KAAK+N,QAAU,Q,gCAKjB,OAAO/N,KAAK+N,SAAW/N,KAAKc,M,iCAI5B,SApIgB,EAoINd,KAAK8Y,iB,aAGFqZ,GACTA,EACFnyB,KAAK8Y,gBAzIS,EA2Id9Y,KAAK8Y,iBAAkB,I,iCAKzB,SAlJgB,EAkJN9Y,KAAK8Y,iB,aAGFqZ,GACTA,EACFnyB,KAAK8Y,gBAvJS,EAyJd9Y,KAAK8Y,iBAAkB,I,8BAKzB,SAhKY,EAgKF9Y,KAAK8Y,iB,aAGLqZ,GACNA,EACFnyB,KAAK8Y,gBArKK,EAuKV9Y,KAAK8Y,iBAAkB,K,8BArIxB,IAND5J,EAMC,EANDA,IACAhM,EAKC,EALDA,WACAvC,EAIC,EAJDA,OACAE,EAGC,EAHDA,UACAkN,EAEC,EAFDA,QACAjN,EACC,EADDA,IAMA,IAJKoO,GAAOhM,IACVgM,EAAMhM,EAAWgM,MAGdvO,EACH,MAAM,IAAI6B,MAAM,gDAGlB,IAAM4vB,EAAavxB,EAAUC,GAEzBC,EAAQP,EAAOC,KAAKC,IAAIC,GAEvBI,IACHA,EAAQ,IAAI0H,IAEZjI,EAAOC,KAAKyD,IAAIvD,EAAQI,IAG1B,IAAIN,EAAOM,EAAML,IAAI0xB,GAQrB,OANK3xB,IACHA,EAAO,IAAIqxB,EAAS5iB,EAAKvO,GACrByxB,GAAYrxB,EAAMmD,IAAIkuB,EAAY3xB,IAGxCA,EAAKyN,MAAMhL,EAAYrC,EAAWkN,EAASjN,GACpCL,M,KAgHXhB,OAAOilB,OAAOoN,EAAS/qB,UAAWoqB,EAAmBC,EAAoBC,EAAsBC,EAAqBC,EAAqBC,EAAwBC,EAAkBC,EAAkBC,EAAuBC,EAAiBC,G,UAE1N1xB,EAAE0kB,O,yBAAVlhB,E,QACH0uB,EAAU,KAAH,OAAQ1uB,GACfiV,EAAKzY,EAAEkyB,GAEbP,EAAS/qB,UAAUsrB,GAAW,SAAU5Z,GACtC,OAAOG,EAAG5Y,KAAKK,KAAMoY,IAGvBqZ,EAAS/qB,UAAT,gBAA4BpD,IAAU,SAAU8U,GAC9C,IAAKG,EAAG5Y,KAAKK,KAAMoY,GACjB,MAAM,IAAIsM,UAAJ,qCAA4CphB,MAVxD,2BAA4B,I,8BAe5B,I,iBAAK,IAAMA,EAAI,KACb,GAAgB,MAAZA,EAAK,GAAY,iBACjBxD,EAAE0kB,MAAMlY,QAAQhJ,GAAQ,GAAGxD,EAAE0kB,MAAMjd,KAAKjE,GAC5C,IAAM2uB,EAAc5O,EAAa/f,GAEjCmuB,EAAS/qB,UAAT,YAAwBpD,IAAU,SAAU8U,GAC1C,OAAO6Z,EAAYjN,UAAUrlB,KAAMyY,KANvC,MAAmBhZ,OAAOkI,KAAK+b,GAA/B,eAA8C,IAU9C,IAAI0L,EAAW0C,EACfnyB,EAAQyC,QAAUgtB,G,6CCzPlB3vB,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQuF,WAqBR,SAAoBqtB,GAClB,IAAI9xB,EAAOT,KAEX,KAAOS,EAAOA,EAAKyC,YACjB,GAAIqvB,EAAS9xB,GAAO,OAAOA,EAG7B,OAAO,MA3BTd,EAAQwX,KA8BR,SAAcob,GACZ,IAAI9xB,EAAOT,KAEX,GACE,GAAIuyB,EAAS9xB,GAAO,OAAOA,QACpBA,EAAOA,EAAKyC,YAErB,OAAO,MApCTvD,EAAQ2E,kBAuCR,WACE,OAAOtE,KAAKkF,YAAW,SAAAuK,GAAC,OAAIA,EAAEtE,iBAvChCxL,EAAQ6yB,mBA0CR,WACE,IAAI/xB,EAAOT,KAEX,EAAG,CACD,IAAKS,EAAKyC,YAAcP,MAAMC,QAAQnC,EAAKI,YAAcJ,EAAK4C,cAC5D,MAEA5C,EAAOA,EAAKyC,iBAEPzC,GAET,GAAIA,IAASA,EAAKiC,aAAejC,EAAKgyB,UACpC,MAAM,IAAIjwB,MAAM,wEAGlB,OAAO/B,GAxDTd,EAAQ+yB,8BA2DR,SAAuC3xB,GACrC,OAAOf,KAAK2yB,6BAA6B5xB,GAAO,SAAU6xB,EAASzlB,EAAG0lB,GACpE,IAAIC,EAD4E,EAE1EnrB,EAAOxH,EAAEyW,aAAagc,EAAQjvB,MAF4C,IAIzDkvB,GAJyD,IAIhF,2BAAmC,KAC3BpyB,EAD2B,QACX0M,EAAI,GAE1B,GAAK2lB,EAKL,GAAIryB,EAAKsN,SAAW+kB,EAAS/kB,UAAYtN,EAAKsN,SACxCtN,EAAKK,IAAMgyB,EAAShyB,IACtBgyB,EAAWryB,OAKUkH,EAAKgF,QAAQmmB,EAAShc,WACvBnP,EAAKgF,QAAQlM,EAAKqW,aAGxCgc,EAAWryB,QAfXqyB,EAAWryB,GARiE,8BA2BhF,OAAOqyB,MAtFXnzB,EAAQgzB,6BA0FR,SAAsC5xB,EAAOgyB,GAAQ,WACnD,IAAKhyB,EAAMR,OACT,OAAOP,KAGT,GAAqB,IAAjBe,EAAMR,OACR,OAAOQ,EAAM,GAGf,IACIiyB,EAAiBC,EADjBC,EAAWtoB,IAETioB,EAAa9xB,EAAM+L,KAAI,SAAArM,GAC3B,IAAM0yB,EAAW,GAEjB,GACEA,EAASxf,QAAQlT,UACTA,EAAOA,EAAKyC,aAAezC,IAAS,GAM9C,OAJI0yB,EAAS5yB,OAAS2yB,IACpBA,EAAWC,EAAS5yB,QAGf4yB,KAEHne,EAAQ6d,EAAW,GAEzBO,EAAW,IAAK,IAAIjmB,EAAI,EAAGA,EAAI+lB,EAAU/lB,IAAK,CAC5C,IAD4C,EACtCkmB,EAAcre,EAAM7H,GADkB,IAGrB0lB,GAHqB,IAG5C,2BAAmC,CACjC,GADiC,QACpB1lB,KAAOkmB,EAClB,MAAMD,GALkC,8BAS5CJ,EAAkB7lB,EAClB8lB,EAAaI,EAGf,GAAIJ,EACF,OAAIF,EACKA,EAAOE,EAAYD,EAAiBH,GAEpCI,EAGT,MAAM,IAAIzwB,MAAM,+BAvIpB7C,EAAQ6W,YA2IR,WACE,IAAI/V,EAAOT,KACLe,EAAQ,GAEd,GACEA,EAAM6G,KAAKnH,SACJA,EAAOA,EAAKyC,YAErB,OAAOnC,GAlJTpB,EAAQ2zB,WAqJR,SAAoBC,GAClB,OAAOA,EAAgBC,aAAaxzB,OArJtCL,EAAQ6zB,aAwJR,SAAsBC,GACpB,QAASzzB,KAAKkF,YAAW,SAAAvE,GAAM,OAAIA,IAAW8yB,MAxJhD9zB,EAAQ+zB,OA2JR,WAAmC,IACjC,IAAIjzB,EAAOT,KADsB,mBAAhB2zB,EAAgB,yBAAhBA,EAAgB,gBAGjC,KAAOlzB,GAAM,WACQkzB,GADR,IACX,2BAAmC,KAAxBhwB,EAAwB,QACjC,GAAIlD,EAAKJ,KAAKsD,OAASA,EAAM,OAAO,GAF3B,8BAKXlD,EAAOA,EAAKyC,WAGd,OAAO,GApKT,IAIgCqD,EAJ5BpG,EAQJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EARttBO,CAAwBd,EAAQ,MAIRE,EAFIF,EAAQ,MAESE,EAAIC,WAEzD,SAASE,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,I,6CCpBlLhH,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQi0B,kBAeR,WACE,GAAI5zB,KAAK6zB,eAAgB,OAAO7zB,KAAK6zB,eACrC,IAAIlwB,EAAO3D,KAAK8zB,sBAAwB3zB,EAAE4zB,oBACtC5zB,EAAE6zB,iBAAiBrwB,KAAOA,EAAOA,EAAKkwB,gBAC1C,OAAO7zB,KAAK6zB,eAAiBlwB,GAlB/BhE,EAAQm0B,mBAuBR,WACE,IAAMzzB,EAAOL,KAAKK,KAElB,IAAKA,EAAM,CACT,GAAiB,SAAbL,KAAKc,KAAkBd,KAAKkD,WAAWsU,uBAAwB,CACjE,IAAMxP,EAAShI,KAAKkD,WAAWA,WACzB+wB,EAAejsB,EAAO9E,WAE5B,MAAmB,SAAf8E,EAAOlH,KAAkBmzB,EAAaC,mBACjC/zB,EAAEg0B,uBAGQ,SAAfnsB,EAAOlH,KAAkBmzB,EAAaG,mBACjCj0B,EAAE4zB,oBAGJ5zB,EAAEk0B,qBAET,OAIJ,GAAIh0B,EAAKwzB,eACP,OAAOxzB,EAAKwzB,eAGd,GAAIS,EAA6B3tB,IAAItG,GACnC,OAGFi0B,EAA6BphB,IAAI7S,GAEjC,IACE,IAAIk0B,EAEAC,EAAUC,EAASp0B,EAAKsD,MAE5B,GAAI6wB,EACF,OAAOA,EAAQvtB,KAAKjH,KAAMK,GAK5B,GAFAm0B,EAAUC,EAASz0B,KAAKkD,WAAWS,MAEP,OAAvB4wB,EAAWC,QAAmB,EAASD,EAASG,YACnD,OAAO10B,KAAKkD,WAAW0wB,oBAZ3B,QAeEU,EAA6B1zB,OAAOP,KArExCV,EAAQg1B,WAyER,SAAoBC,EAAUC,GAC5B,OAAOC,EAAYF,EAAU50B,KAAK4zB,oBAAqBiB,IAzEzDl1B,EAAQo1B,gBAoGR,SAAyBxvB,GACvB,IAAM5B,EAAO3D,KAAK4zB,oBAClB,GAAIzzB,EAAE60B,oBAAoBrxB,GAAO,OAAO,EAExC,GAAIxD,EAAE80B,sBAAsBtxB,GAAO,WACbA,EAAKugB,OADQ,IACjC,2BAAgC,KAArBgR,EAAqB,QAC9B,GAAI/0B,EAAE60B,oBAAoBE,IAAUJ,EAAYvvB,EAAM2vB,GAAO,GAC3D,OAAO,GAHsB,8BAOjC,OAAO,EAEP,OAAOJ,EAAYvvB,EAAM5B,GAAM,IAhHnChE,EAAQw1B,wBAoHR,SAAiCC,GAC/B,IAAMlpB,EAAOlM,KAAK4zB,oBACZxnB,EAAQgpB,EAASxB,oBAEvB,IAAKzzB,EAAE60B,oBAAoB9oB,IAAS/L,EAAEk1B,qBAAqBnpB,GACzD,OAAOE,EAAMzI,OAASuI,EAAKvI,KAG7B,OAAO,GA3HThE,EAAQmsB,cA8HR,SAAuBwJ,GACrB,IAAM3xB,EAAO3D,KAAK4zB,oBAClB,OAAOzzB,EAAEo1B,wBAAwB5xB,IAASxD,EAAE4J,aAAapG,EAAKkE,GAAI,CAChEtC,KAAM+vB,KA/HV,IAAIb,EAAWttB,EAAwBd,EAAQ,MAE3ClG,EAAIgH,EAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAElL,SAASU,EAAwBZ,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAyE,OAA7D8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAkBA,EAS9tB,IAAM0tB,EAA+B,IAAIrhB,QAyDzC,SAAS6hB,EAAYF,EAAUjxB,EAAMkxB,GACnC,GAAiB,WAAbD,EACF,OAAOz0B,EAAEq1B,uBAAuB7xB,GAC3B,GAAiB,WAAbixB,EACT,OAAOz0B,EAAEs1B,uBAAuB9xB,GAC3B,GAAiB,YAAbixB,EACT,OAAOz0B,EAAEu1B,wBAAwB/xB,GAC5B,GAAiB,QAAbixB,EACT,OAAOz0B,EAAE60B,oBAAoBrxB,GACxB,GAAiB,UAAbixB,EACT,OAAOz0B,EAAEw1B,sBAAsBhyB,GAC1B,GAAiB,UAAbixB,EACT,OAAOz0B,EAAEy1B,sBAAsBjyB,GAC1B,GAAiB,SAAbixB,EACT,OAAOz0B,EAAE01B,qBAAqBlyB,GAE9B,GAAIkxB,EACF,OAAO,EAEP,MAAM,IAAIryB,MAAJ,4BAA+BoyB,M,iCCrG3Cn1B,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQm2B,mBAwCR,WACE,IAAIC,EAGJ,IADW/1B,KAAKU,IAAI,MACZqJ,eAAgB,OACxB,IAAM9B,EAAOjI,KAAKU,IAAI,QAClBiD,EAAOsE,EAAK2rB,oBAEuC,uBAAhC,OAAjBmC,EAAQpyB,QAAgB,EAASoyB,EAAMpyB,OACvCsE,EAAKoC,oBAAsBpC,EAAKvH,IAAI,UAAUqJ,aAAa,CAC7DxE,KAAM,YACD0C,EAAK7D,MAAMwmB,WAAW,SAAS,KACpCjnB,EAAOqyB,KAIX,OAAOryB,GAvDThE,EAAQs2B,mBAAqBA,EAC7Bt2B,EAAQu2B,cA+DR,SAAuB71B,GACrB,GAAIL,KAAKU,IAAI,UAAUqJ,eACrB,OAAO5J,EAAEg2B,sBAAsB91B,EAAKmF,SAhExC7F,EAAQy2B,gBAoER,WACE,OAAOj2B,EAAEg0B,wBApEXx0B,EAAQ+pB,gBAuER,SAAyBrpB,GACvB,IAAM4K,EAAW5K,EAAK4K,SAEtB,GAAiB,SAAbA,EACF,OAAO9K,EAAEk0B,qBACJ,GAAIl0B,EAAEk2B,uBAAuB1pB,QAAQ1B,IAAa,EACvD,OAAO9K,EAAEm2B,uBACJ,GAAIn2B,EAAEo2B,uBAAuB5pB,QAAQ1B,IAAa,EACvD,OAAO9K,EAAEg0B,uBACJ,GAAIh0B,EAAEq2B,wBAAwB7pB,QAAQ1B,IAAa,EACxD,OAAO9K,EAAEs2B,yBAhFb92B,EAAQ+2B,iBAoFR,SAA0Br2B,GACxB,IAAM4K,EAAW5K,EAAK4K,SAEtB,GAAI9K,EAAEw2B,wBAAwBhqB,QAAQ1B,IAAa,EACjD,OAAO9K,EAAEm2B,uBACJ,GAAIn2B,EAAEy2B,yBAAyBjqB,QAAQ1B,IAAa,EACzD,OAAO9K,EAAEs2B,wBACJ,GAAiB,MAAbxrB,EAAkB,CAC3B,IAAMmB,EAAQpM,KAAKU,IAAI,SACjBwL,EAAOlM,KAAKU,IAAI,QAEtB,OAAIwL,EAAKyoB,WAAW,WAAavoB,EAAMuoB,WAAW,UACzCx0B,EAAEm2B,uBACApqB,EAAKyoB,WAAW,WAAavoB,EAAMuoB,WAAW,UAChDx0B,EAAEg0B,uBAGJh0B,EAAE02B,oBAAoB,CAAC12B,EAAEg0B,uBAAwBh0B,EAAEm2B,2BApG9D32B,EAAQm3B,kBAwGR,WACE,IAAMC,EAAgB,CAAC/2B,KAAKU,IAAI,QAAQkzB,oBAAqB5zB,KAAKU,IAAI,SAASkzB,qBAE/E,GAAIzzB,EAAE62B,mBAAmBD,EAAc,KAAO52B,EAAE82B,kBAC9C,OAAO92B,EAAE82B,kBAAkBF,GAG7B,GAAI52B,EAAE+2B,oBACJ,OAAO/2B,EAAE+2B,oBAAoBH,GAG/B,OAAO52B,EAAEg3B,0BAA0BJ,IAlHrCp3B,EAAQy3B,sBAqHR,WACE,IAAML,EAAgB,CAAC/2B,KAAKU,IAAI,cAAckzB,oBAAqB5zB,KAAKU,IAAI,aAAakzB,qBAEzF,GAAIzzB,EAAE62B,mBAAmBD,EAAc,KAAO52B,EAAE82B,kBAC9C,OAAO92B,EAAE82B,kBAAkBF,GAG7B,GAAI52B,EAAE+2B,oBACJ,OAAO/2B,EAAE+2B,oBAAoBH,GAG/B,OAAO52B,EAAEg3B,0BAA0BJ,IA/HrCp3B,EAAQ03B,mBAkIR,WACE,OAAOr3B,KAAKU,IAAI,eAAe8Z,MAAMoZ,qBAlIvCj0B,EAAQ23B,wBAqIR,WACE,OAAOt3B,KAAKU,IAAI,cAAckzB,qBArIhCj0B,EAAQ4pB,qBAwIR,WACE,OAAOvpB,KAAKU,IAAI,SAASkzB,qBAxI3Bj0B,EAAQ8pB,iBA2IR,SAA0BppB,GACxB,IAAM4K,EAAW5K,EAAK4K,SAEtB,GAAiB,OAAbA,GAAkC,OAAbA,EACvB,OAAO9K,EAAEm2B,wBA9Ib32B,EAAQ43B,cAkJR,WACE,OAAOp3B,EAAEg0B,wBAlJXx0B,EAAQ63B,eAqJR,WACE,OAAOr3B,EAAEm2B,wBArJX32B,EAAQ83B,eAwJR,WACE,OAAOt3B,EAAEs2B,yBAxJX92B,EAAQ+3B,YA2JR,WACE,OAAOv3B,EAAEw3B,6BA3JXh4B,EAAQi4B,cA8JR,WACE,OAAOz3B,EAAEg2B,sBAAsBh2B,EAAEmF,WAAW,YA9J9C3F,EAAQk4B,iBAiKR,WACE,OAAO13B,EAAEg2B,sBAAsBh2B,EAAEmF,WAAW,YAjK9C3F,EAAQq2B,gBAAkBA,EAC1Br2B,EAAQm4B,YAAcA,EACtBn4B,EAAQo4B,iBAAmBp4B,EAAQoqB,gBAAkBpqB,EAAQq4B,oBAAsBr4B,EAAQs4B,wBAA0Bt4B,EAAQu4B,mBA4K7H,WACE,OAAO/3B,EAAEg2B,sBAAsBh2B,EAAEmF,WAAW,cA5K9C3F,EAAQ2Q,eAoLR,WAA0B,IAEtB9K,EACExF,KAAKK,KADPmF,OAGF,GAAI2yB,EAAa3yB,GACf,OAAOrF,EAAEi4B,oBAAoBj4B,EAAEg0B,wBAC1B,GAAIkE,EAAY7yB,IAAW8yB,EAAe9yB,GAC/C,OAAOrF,EAAEi4B,oBAAoBj4B,EAAE4zB,qBAC1B,GAAIwE,EAAgB/yB,GACzB,OAAOrF,EAAEi4B,oBAAoBj4B,EAAEq4B,oBAAoB,CAACr4B,EAAEg0B,uBAAwBh0B,EAAE4zB,uBAGlF,OAAO0E,EAAYz4B,KAAKU,IAAI,YAhM9Bf,EAAQ+4B,yBAmMR,WACE,OAAOD,EAAYz4B,KAAKU,IAAI,SAnM9BjB,OAAOC,eAAeC,EAAS,aAAc,CAC3CovB,YAAY,EACZruB,IAAK,WACH,OAAOi4B,EAAkBv2B,WAI7B,IAIgCmE,EAJ5BpG,EAQJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EARttBO,CAAwBd,EAAQ,KAEpCsyB,GAE4BpyB,EAFeF,EAAQ,OAEFE,EAAIC,WAAaD,EAAM,CAAEnE,QAASmE,GAEvF,SAASG,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EAuBlL,SAASwvB,EAAmB51B,GAC1B,OAAOA,EAAKwzB,eA0Hd,SAASmC,IACP,OAAO71B,EAAEg2B,sBAAsBh2B,EAAEmF,WAAW,UAG9C,SAASwyB,IACP,OAAO9B,IA5HTC,EAAmBvB,aAAc,EA+HjCoD,EAAYpD,aAAc,EAM1B,IAAM2D,EAAcl4B,EAAEy4B,2BAA2B,cAC3CT,EAAeh4B,EAAEy4B,2BAA2B,eAC5CN,EAAiBn4B,EAAEy4B,2BAA2B,iBAC9CL,EAAkBp4B,EAAEy4B,2BAA2B,kBAsBrD,SAASH,EAAYjzB,GAGnB,IAFAA,EAASA,EAAOsF,WAELK,aAAc,CACvB,GAAI3F,EAAOhB,GAAG,SACZ,OAAIgB,EAAOhB,GAAG,aACLrE,EAAEg2B,sBAAsBh2B,EAAEmF,WAAW,kBAErCnF,EAAEg2B,sBAAsBh2B,EAAEmF,WAAW,YAG9C,GAAIE,EAAOnF,KAAKw4B,WACd,OAAOrzB,EAAOnF,KAAKw4B,c,6CC5O3Bp5B,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQyC,QAQR,SAAkB/B,GAChB,IAAKL,KAAK8mB,eAAgB,OAC1B,IAAMtc,EAAUxK,KAAKoE,MAAM4F,WAAW3J,EAAKkF,MAE3C,GAAIiF,EACF,OAAIA,EAAQlF,WAAWuuB,eACdrpB,EAAQlF,WAAWuuB,eAahC,SAAoDrpB,EAAS/J,EAAM8E,GACjE,IAAM2e,EAAQ,GACR4U,EAA6B,GAC/BruB,EAAqBsuB,EAA4BvuB,EAAS/J,EAAMq4B,GAC9DE,EAAWC,EAAyBzuB,EAAS/J,EAAM8E,GAEzD,GAAIyzB,EAAU,CACZ,IAAME,EAAyBH,EAA4BvuB,EAASwuB,EAASG,aAC7E1uB,EAAqBA,EAAmBsoB,QAAO,SAAAtyB,GAAI,OAAIy4B,EAAuBvsB,QAAQlM,GAAQ,KAC9FyjB,EAAMtc,KAAKoxB,EAASnF,gBAGtB,GAAIppB,EAAmBlK,OAAQ,CAC7BkK,EAAqBA,EAAmB8G,OAAOunB,GADlB,UAGLruB,GAHK,IAG7B,2BAA4C,KAAjC2uB,EAAiC,QAC1ClV,EAAMtc,KAAKwxB,EAAUxF,sBAJM,+BAQ/B,IAAK1P,EAAM3jB,OACT,OAGF,GAAIJ,EAAE62B,mBAAmB9S,EAAM,KAAO/jB,EAAE82B,kBACtC,OAAO92B,EAAE82B,kBAAkB/S,GAG7B,GAAI/jB,EAAE+2B,oBACJ,OAAO/2B,EAAE+2B,oBAAoBhT,GAG/B,OAAO/jB,EAAEg3B,0BAA0BjT,GA3CxBmV,CAA2C7uB,EAASxK,KAAMK,EAAKkF,MAI1E,GAAkB,cAAdlF,EAAKkF,KACP,OAAOpF,EAAEk0B,qBACJ,GAAkB,QAAdh0B,EAAKkF,MAAgC,aAAdlF,EAAKkF,KACrC,OAAOpF,EAAEm2B,uBACAj2B,EAAKkF,MAtBlB,IAAIpF,EAIJ,SAAiCoG,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAO,GAAY,OAARA,GAA+B,kBAARA,GAAmC,oBAARA,EAAsB,MAAO,CAAEnE,QAASmE,GAAS,IAAIE,EAAQC,IAA4B,GAAID,GAASA,EAAME,IAAIJ,GAAQ,OAAOE,EAAM/F,IAAI6F,GAAQ,IAAIK,EAAS,GAAQC,EAAwBpH,OAAOC,gBAAkBD,OAAOqH,yBAA0B,IAAK,IAAIhG,KAAOyF,EAAO,GAAI9G,OAAOsH,UAAUC,eAAeC,KAAKV,EAAKzF,GAAM,CAAE,IAAIoG,EAAOL,EAAwBpH,OAAOqH,yBAAyBP,EAAKzF,GAAO,KAAUoG,IAASA,EAAKxG,KAAOwG,EAAKhD,KAAQzE,OAAOC,eAAekH,EAAQ9F,EAAKoG,GAAgBN,EAAO9F,GAAOyF,EAAIzF,GAAY8F,EAAOxE,QAAUmE,EAASE,GAASA,EAAMvC,IAAIqC,EAAKK,GAAW,OAAOA,EAJttBO,CAAwBd,EAAQ,KAExC,SAASK,IAA6B,GAAuB,oBAAZU,QAAwB,OAAO,KAAM,IAAIX,EAAQ,IAAIW,QAAqE,OAA1DV,EAA2B,WAAc,OAAOD,GAAiBA,EA0DlL,SAASsyB,EAA4BvuB,EAAS/J,EAAM64B,GAClD,IAAM1N,EAAaphB,EAAQC,mBAAmB4H,QAE9C,OADAuZ,EAAWjY,QAAQnJ,EAAQ/J,MACpBmrB,EAAWmH,QAAO,SAAAqG,GAGvB,IAAM/hB,GAFN+hB,EAAYA,EAAUtuB,WAEGqL,gCAAgC1V,GAGzD,OADI64B,GAAwB,YAAXjiB,GAAsBiiB,EAAU1xB,KAAKwxB,GACpC,WAAX/hB,KAIX,SAASkiB,EAAoCh0B,EAAM9E,GACjD,IAGIyV,EAyBAsjB,EACAC,EA7BExuB,EAAWxK,EAAKJ,KAAK4K,SACrBmB,EAAQ3L,EAAKC,IAAI,SAASoK,UAC1BoB,EAAOzL,EAAKC,IAAI,QAAQoK,UAa9B,GAVIoB,EAAKnC,aAAa,CACpBxE,SAEA2Q,EAAS9J,EACAA,EAAMrC,aAAa,CAC5BxE,WAEA2Q,EAAShK,GAGPgK,EACF,MAAiB,QAAbjL,EACKiL,EAAO0d,oBAGZzzB,EAAEu5B,gCAAgC/sB,QAAQ1B,IAAa,EAClD9K,EAAEm2B,4BAGX,EAGF,IAAiB,QAAbrrB,GAAmC,OAAbA,KAItBiB,EAAKnB,kBAAkB,CACzBE,SAAU,YAEVuuB,EAAattB,EACbutB,EAAWrtB,GACFA,EAAMrB,kBAAkB,CACjCE,SAAU,aAEVuuB,EAAaptB,EACbqtB,EAAWvtB,GAGRstB,GACAA,EAAW94B,IAAI,YAAYqJ,aAAa,CAC3CxE,WAEFk0B,EAAWA,EAAS3uB,WACNR,aAAd,CACA,IAAMqvB,EAAYF,EAASp5B,KAAKT,MAChC,GAAyB,kBAAd+5B,EACX,OAAOx5B,EAAEy5B,kCAAkCD,IAuB7C,SAASV,EAAyBzuB,EAAS/J,EAAM8E,GAC/C,IAAM4zB,EArBR,SAAkC3uB,EAAS/J,EAAM8E,GAG/C,IAFA,IAAIrC,EAEGA,EAAazC,EAAKyC,YAAY,CACnC,GAAIA,EAAW8Y,iBAAmB9Y,EAAWgH,0BAA2B,CACtE,GAAiB,SAAbzJ,EAAKK,IACP,OAGF,OAAOoC,EAGT,GAAIA,EAAWiI,cACTjI,EAAWA,WAAWkB,MAAM4F,WAAWzE,KAAUiF,EAAS,OAGhE/J,EAAOyC,GAKW22B,CAAyBrvB,EAAS/J,EAAM8E,GAC5D,GAAK4zB,EAAL,CAKA,IAJA,IACMp4B,EAAQ,CADDo4B,EAAYz4B,IAAI,SAEvBwjB,EAAQ,GAEL/W,EAAI,EAAGA,EAAIpM,EAAMR,OAAQ4M,IAAK,CACrC,IAAM1M,EAAOM,EAAMoM,GAEnB,GAAI1M,EAAKuL,sBACoB,OAAvBvL,EAAKJ,KAAK4K,WACZlK,EAAM6G,KAAKnH,EAAKC,IAAI,SACpBK,EAAM6G,KAAKnH,EAAKC,IAAI,gBAEjB,GAAID,EAAK6L,qBAAsB,CACpC,IAAM3I,EAAO41B,EAAoCh0B,EAAM9E,GACnDkD,GAAMugB,EAAMtc,KAAKjE,IAIzB,OAAIugB,EAAM3jB,OACJJ,EAAE62B,mBAAmB9S,EAAM,KAAO/jB,EAAE82B,kBAC/B,CACLpD,eAAgB1zB,EAAE82B,kBAAkB/S,GACpCiV,eAIAh5B,EAAE+2B,oBACG,CACLrD,eAAgB1zB,EAAE+2B,oBAAoBhT,GACtCiV,eAIG,CACLtF,eAAgB1zB,EAAEg3B,0BAA0BjT,GAC5CiV,eAIGF,EAAyBE,EAAa5zB","file":"static/js/vendors-runtime-traverse.2543b401.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = _interopRequireWildcard(require(\"./index\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}"],"sourceRoot":""}