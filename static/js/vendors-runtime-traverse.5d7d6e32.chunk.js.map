{"version":3,"sources":["../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js"],"names":["Object","defineProperty","exports","value","clear","clearPath","clearScope","scope","path","WeakMap","shareCommentsWithSiblings","this","key","node","trailing","trailingComments","leading","leadingComments","prev","getSibling","next","hasPrev","Boolean","hasNext","addComments","addComment","type","content","line","t","comments","obj","__esModule","default","cache","_getRequireWildcardCache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","require","explode","verify","merge","visitors","states","wrapper","rootVisitor","i","length","visitor","state","keys","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","parts","split","fns","enter","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","aliases","FLIPPED_ALIAS_KEYS","deprecratedKey","DEPRECATED_KEYS","console","trace","alias","existing","assign","_verified","Error","validateVisitorMethods","TYPES","indexOf","visitorKey","val","concat","fn","TypeError","oldVisitor","newVisitor","Array","isArray","map","newFn","toString","exit","checkPath","apply","arguments","dest","src","Hub","msg","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","opts","parent","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","parentPath","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isScope","isBlockScoped","isVar","loc","isUser","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","_renamer","_interopRequireDefault","_index","_binding","_globals","_cache","gatherNodeParts","isModuleDeclaration","source","specifiers","declaration","isModuleSpecifier","local","isLiteral","push","object","property","callee","properties","argument","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","getFunctionParent","getProgramParent","registerBinding","Declaration","isDeclaration","registerDeclaration","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","declarations","decl","getBindingIdentifiers","LabeledStatement","addGlobal","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","Block","paths","bodyPath","CatchClause","Function","isFunctionExpression","NOT_LOCAL_BINDING","params","param","ClassExpression","uid","cached","block","labels","Map","inited","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","uids","defaultName","join","slice","generateUidBasedOnNode","isThisExpression","isSuper","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","hub","buildError","oldName","newName","rename","sep","repeat","log","violations","allowArrayLike","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","unshift","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","unaryExpression","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","globals","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elements","elem","prop","isMethod","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","isPureish","data","crawl","create","isFunction","programParent","crawling","traverse","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","variableDeclaration","unshiftContainer","setData","declarator","variableDeclarator","pop","isFunctionParent","isBlockParent","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","findParent","p","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","enumerable","_path","_scope","_hub","_context","noScope","VISITOR_KEYS","hasDenylistedType","stop","cheap","traverseFast","skipKeys","context","visit","clearNode","removeProperties","delete","tree","hasType","denylistTypes","denylist","SHOULD_SKIP","SHOULD_STOP","REMOVED","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","debug","NodePath","contexts","_traverseFlags","container","listKey","def","undefined","SyntaxError","validate","inList","message","enabled","getPathLocation","code","v","targetNode","setup","typeKey","virtualType","TraversalContext","queue","notPriority","trap","priorityQueue","shouldVisit","visitQueue","visited","WeakSet","resync","pushContext","process","add","popContext","nodes","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","bindingIdentifierEquals","skip","Renamer","parentDeclar","maybeExportDeclar","isExportDefaultDeclaration","find","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","forEach","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","callback","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","parse","err","_codeFrame","codeFrameColumns","start","column","replaceWith","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","arrowFunctionExpression","blockStatement","hoistVariablesVisitor","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","assignmentExpression","arrowFunctionToExpression","FUNCTION_TYPES","awaitExpression","replaceInline","_containerInsertAfter","VariableDeclaration","exprs","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","resolved","item","isSequenceExpression","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","_evaluate","raw","str","cooked","expr","String","toComputedKey","stringLiteral","bodyNode","statements","stringPath","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","skipKey","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","_remove","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","self","isWhile","isSwitchCase","insertBefore","isExportNamedDeclaration","isJSXElement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","temp","fromIndex","incrementBy","constructor","hoist","hoister","_hoister","run","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","JSXExpressionContainer","getOpposite","addCompletionRecords","isDoExpression","isTryStatement","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","_getKey","_getPattern","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","shift","_ids","getOuterBindingIdentifierPaths","_findBreak","_findBreak2","isBreakStatement"],"mappings":"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","file":"static/js/vendors-runtime-traverse.5d7d6e32.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecratedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecratedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`);\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if (node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if (node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent == null ? void 0 : parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, allowArrayLike) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (allowArrayLike) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isFunction()) {\n      if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (const kind of arguments) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts, scope, state, parentPath) {\n  if (!parent) return;\n  if (!opts) opts = {};\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nexports.default = NodePath;\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (binding.type === \"hoisted\") {}\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType() {\n  let path = this;\n\n  while (path) {\n    for (const type of arguments) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(right) {\n  const left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  const {\n    node\n  } = path;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === \"raw\") {\n      return evaluateQuasis(path, node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[node.callee.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  const node = this.node;\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (specCompliant) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, specCompliant = false, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || specCompliant) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (specCompliant) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.get(\"operator\").node !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    let {\n      node\n    } = path;\n    if (path.isFunction()) node = node.body;\n\n    for (const directive of node.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      let {\n        scope\n      } = this;\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: this.node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), this.node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(nodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}"],"sourceRoot":""}