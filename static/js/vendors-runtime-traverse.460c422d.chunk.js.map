{"version":3,"sources":["../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js"],"names":["Object","defineProperty","exports","value","clear","clearPath","clearScope","scope","path","WeakMap","matchesPattern","pattern","allowPartial","t","this","node","has","isStatic","isnt","key","equals","isNodeType","type","isType","canHaveVariableDeclarationOrExpression","parentPath","isFor","canSwapBetweenExpressionAndStatement","replacement","isArrowFunctionExpression","isExpression","isBlockStatement","isCompletionRecord","allowInsideFunction","first","container","isFunction","Array","isArray","length","isProgram","isStatementOrBlock","isLabeledStatement","STATEMENT_OR_BLOCK_KEYS","includes","referencesImport","moduleSource","importName","isReferencedIdentifier","binding","getBinding","name","kind","parent","isImportDeclaration","source","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","imported","getSource","end","code","hub","getCode","slice","start","willIMaybeExecuteBefore","target","_guessExecutionStatusRelativeTo","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","paths","getAncestry","indexOf","commonIndex","Error","isExecutionUncertainInList","divergence","listKey","keys","VISITOR_KEYS","keyPosition","parentKey","isFunctionDeclaration","isExportDeclaration","id","references","allStatus","referencePaths","find","isCallExpression","executionOrderCheckedNodes","add","status","delete","resolve","dangerous","resolved","_resolve","push","isVariableDeclarator","get","isIdentifier","constant","ret","isTypeCastExpression","isMemberExpression","targetKey","toComputedKey","isLiteral","targetName","isObjectExpression","props","prop","isProperty","match","isArrayExpression","isNaN","elem","isConstantExpression","isRegExpLiteral","isTemplateLiteral","every","expression","isUnaryExpression","isBinaryExpression","isInStrictMode","sourceType","isClass","body","directives","is","obj","__esModule","default","cache","_getRequireWildcardCache","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","require","val","getFunctionParent","getProgramParent","isExecutionUncertain","maxIndex","i","WeakSet","opts","debug","_call","fns","fn","state","then","_traverseFlags","isBlacklisted","isDenylisted","_this$opts$denylist","denylist","blacklist","visit","shouldSkip","shouldStop","_index","skipKeys","skip","skipKey","stop","_index2","SHOULD_SKIP","SHOULD_STOP","setScope","noScope","getScope","init","setContext","context","resync","removed","_resyncParent","_resyncList","_resyncKey","setKey","inList","newContainer","_resyncRemoved","_markRemoved","popContext","contexts","pop","undefined","pushContext","setup","_this$node","requeue","pathToQueue","maybeQueue","_getQueueContexts","remove","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","bindings","getBindingIdentifiers","forEach","removeBinding","_removalHooks","hooks","splice","updateSiblingKeys","_replaceWith","REMOVED","_cache","buildCodeFrameError","self","isWhile","isSwitchCase","isVariableDeclaration","declarations","isExpressionStatement","isSequenceExpression","expressions","replaceWith","isBinary","right","left","isIfStatement","isLoop","insertBefore","nodes","_verifyNodeList","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isJSXElement","isForStatement","replaceExpressionWithStatements","_containerInsertBefore","shouldInsertCurrentNode","blockStatement","unshiftContainer","_containerInsert","from","to","getSibling","queue","_containerInsertAfter","insertAfter","map","expressionStatement","isMethod","computed","temp","generateDeclaredUidIdentifier","unshift","assignmentExpression","cloneNode","pushContainer","fromIndex","incrementBy","constructor","msg","replaceWithMultiple","hoist","hoister","_hoister","run","_interopRequireDefault","referenceVisitor","ReferencedIdentifier","isJSXIdentifier","react","isCompatTag","isJSXMemberExpression","breakOnScopePaths","constantViolations","mutableBinding","PathHoister","scopes","attachAfter","bindingIdentifierEquals","identifier","isCompatibleScope","_getAttachmentPath","targetScope","hasOwnBinding","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","_blockHoist","isStatement","traverse","getCompatibleScopes","attachTo","getAttachmentPath","uid","generateUidIdentifier","declarator","variableDeclarator","variableDeclaration","attached","children","JSXExpressionContainer","getOpposite","getCompletionRecords","addCompletionRecords","isDoExpression","isTryStatement","isCatchClause","isSwitchStatement","cases","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","parts","split","_getKey","_getPattern","_","part","duplicates","getOuterBindingIdentifiers","getBindingIdentifierPaths","outerOnly","search","concat","ids","create","shift","_ids","declaration","isFunctionExpression","child","getOuterBindingIdentifierPaths","statements","_findBreak","_findBreak2","isBreakStatement","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","line","comments","explode","verify","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","enter","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","aliases","FLIPPED_ALIAS_KEYS","deprecratedKey","DEPRECATED_KEYS","console","trace","alias","existing","assign","_verified","validateVisitorMethods","TYPES","visitorKey","TypeError","oldVisitor","newVisitor","newFn","toString","exit","checkPath","apply","arguments","dest","src","Hub","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","isReferenced","grandparent","isBinding","isForXStatement","isScope","isBlockScoped","isVar","loc","isUser","isPure","isFlow","importKind","exportKind","isObjectPattern","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","specifiers","isModuleSpecifier","local","object","property","callee","properties","argument","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","registerBinding","Declaration","registerDeclaration","ForXStatement","isPattern","ExportDeclaration","isClassDeclaration","reference","decl","LabeledStatement","addGlobal","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","Block","bodyPath","CatchClause","Function","NOT_LOCAL_BINDING","params","param","ClassExpression","cached","block","labels","Map","inited","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","uids","defaultName","join","generateUidBasedOnNode","isThisExpression","isSuper","dontPush","generateUidIdentifierBasedOnNode","buildError","oldName","newName","rename","sep","repeat","log","violations","allowArrayLike","isGenericType","callExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","label","registerLabel","specifier","unaryExpression","reassign","bindingPath","ReferenceError","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","globals","constantsOnly","superClass","isClassBody","method","elements","isTaggedTemplateExpression","tag","quasi","isPureish","data","crawl","programParent","crawling","ref","ensureBlock","unique","blockHoist","dataKey","declarPath","getData","setData","isFunctionParent","isBlockParent","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","findParent","p","builtin","Binding","referenced","clearValue","hasDeoptedValue","hasValue","enumerable","_path","_scope","_hub","_context","hasDenylistedType","cheap","traverseFast","clearNode","removeProperties","tree","hasType","denylistTypes","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","NodePath","def","SyntaxError","validate","message","enabled","getPathLocation","v","targetNode","typeKey","virtualType","TraversalContext","notPriority","trap","priorityQueue","shouldVisit","visitQueue","visited","process","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","Renamer","parentDeclar","maybeExportDeclar","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","callback","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","depthLoop","shouldMatch","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","functions","inferAnnotationFromBinaryExpression","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isConditionalExpression","getParentConditionalPath","isLogicalExpression","_pathCache$get","inheritLeadingComments","inheritTrailingComments","replaceWithSourceString","_parser","parse","err","_codeFrame","codeFrameColumns","column","nodePath","oldNode","inheritsComments","removeComments","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","arrowFunctionExpression","hoistVariablesVisitor","completionRecords","loop","returnStatement","arrowFunctionToExpression","FUNCTION_TYPES","awaitExpression","replaceInline","VariableDeclaration","exprs","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","item","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","NaN","prefix","arg","arr","elems","elemValue","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","_evaluate","raw","str","cooked","expr","String","stringLiteral","bodyNode","stringPath","arrowFunctionToShadowed","unwrapFunctionEnvironment","hoistFunctionEnvironment","allowInsertArrow","specCompliant","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty"],"mappings":"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","file":"static/js/vendors-runtime-traverse.460c422d.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.get(\"operator\").node !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    let {\n      node\n    } = path;\n    if (path.isFunction()) node = node.body;\n\n    for (const directive of node.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      let {\n        scope\n      } = this;\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: this.node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), this.node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(nodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecratedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecratedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`);\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if (node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if (node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent == null ? void 0 : parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, allowArrayLike) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (allowArrayLike) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isFunction()) {\n      if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (const kind of arguments) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = traverse;\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts, scope, state, parentPath) {\n  if (!parent) return;\n  if (!opts) opts = {};\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nexports.default = NodePath;\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (binding.type === \"hoisted\") {}\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType() {\n  let path = this;\n\n  while (path) {\n    for (const type of arguments) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(right) {\n  const left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  const {\n    node\n  } = path;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === \"raw\") {\n      return evaluateQuasis(path, node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[node.callee.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  const node = this.node;\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (specCompliant) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, specCompliant = false, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || specCompliant) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (specCompliant) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}"],"sourceRoot":""}