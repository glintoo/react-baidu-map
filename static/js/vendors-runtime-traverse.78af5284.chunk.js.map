{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js"],"names":["Object","defineProperty","exports","value","hooks","self","parent","key","isWhile","isSwitchCase","isExportDeclaration","isLabeledStatement","listKey","isVariableDeclaration","node","declarations","length","isExpressionStatement","remove","isSequenceExpression","expressions","replaceWith","isBinary","right","left","isIfStatement","isLoop","isArrowFunctionExpression","type","body","insertBefore","nodes_","this","_assertUnremoved","nodes","_verifyNodeList","parentPath","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","push","replaceExpressionWithStatements","Array","isArray","container","_containerInsertBefore","isStatementOrBlock","shouldInsertCurrentNode","expression","t","blockStatement","unshiftContainer","Error","_containerInsert","from","updateSiblingKeys","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","_containerInsertAfter","insertAfter","map","isExpression","expressionStatement","scope","isPattern","assertExpression","callExpression","arrowFunctionExpression","get","isMethod","computed","temp","generateDeclaredUidIdentifier","unshift","assignmentExpression","cloneNode","pushContainer","fromIndex","incrementBy","_cache","msg","_index","default","setContext","verifiedNodes","replaceWithMultiple","hoist","hoister","_hoister","run","require","_interopRequireDefault","obj","__esModule","cache","_getRequireWildcardCache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","WeakMap","referenceVisitor","ReferencedIdentifier","state","isJSXIdentifier","react","isCompatTag","name","isJSXMemberExpression","isFunction","breakOnScopePaths","binding","getBinding","constantViolations","mutableBinding","stop","bindings","PathHoister","scopes","attachAfter","keys","bindingIdentifierEquals","identifier","isCompatibleScope","indexOf","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","_blockHoist","isStatement","constant","traverse","getCompatibleScopes","attachTo","getAttachmentPath","getFunctionParent","uid","generateUidIdentifier","declarator","variableDeclarator","isVariableDeclarator","variableDeclaration","attached","children","jsxExpressionContainer","getOpposite","getCompletionRecords","addCompletionRecords","isDoExpression","isFor","isBlockStatement","isTryStatement","isCatchClause","isSwitchStatement","cases","isLastCaseWithConsequent","consequent","breakStatement","findBreak","prevSibling","getPrevSibling","buildUndefinedNode","statementFinder","statement","some","completionRecordForSwitch","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","parts","split","_getKey","_getPattern","_","part","getBindingIdentifiers","duplicates","getOuterBindingIdentifiers","getBindingIdentifierPaths","outerOnly","search","concat","ids","create","id","shift","isIdentifier","_ids","declaration","isFunctionDeclaration","isFunctionExpression","child","getOuterBindingIdentifierPaths","statements","_findBreak","_findBreak2","isBreakStatement","shareCommentsWithSiblings","trailing","trailingComments","leading","leadingComments","prev","next","hasPrev","Boolean","hasNext","addComments","addComment","content","line","comments","explode","verify","merge","visitors","states","wrapper","rootVisitor","visitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","virtualTypes","_exploded","nodeType","shouldIgnoreKey","fns","enter","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","aliases","FLIPPED_ALIAS_KEYS","deprecratedKey","DEPRECATED_KEYS","console","trace","alias","existing","assign","_verified","validateVisitorMethods","TYPES","visitorKey","val","fn","TypeError","oldVisitor","newVisitor","newFn","toString","exit","checkPath","apply","arguments","dest","src","Hub","clear","clearPath","clearScope","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","opts","isReferenced","isMemberExpression","grandparent","isBinding","isForXStatement","init","isReferencedIdentifier","isScope","isBlockScoped","isVar","loc","isUser","isPure","isFlow","isImportDeclaration","importKind","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","_renamer","_binding","_globals","gatherNodeParts","isModuleDeclaration","isExportAllDeclaration","source","specifiers","isModuleSpecifier","local","isLiteral","object","property","callee","properties","argument","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","getProgramParent","registerBinding","Declaration","registerDeclaration","references","ForXStatement","ExportDeclaration","isClassDeclaration","reference","decl","LabeledStatement","addGlobal","getBlockParent","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","Block","bodyPath","CatchClause","Function","NOT_LOCAL_BINDING","params","param","ClassExpression","block","labels","inited","globals","uids","data","crawling","cached","Map","generateUid","toIdentifier","replace","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","join","slice","generateUidBasedOnNode","isThisExpression","isSuper","dontPush","isStatic","generateUidIdentifierBasedOnNode","hub","buildError","oldName","newName","rename","sep","repeat","log","violations","allowArrayLike","isGenericType","isArrayExpression","memberExpression","helperName","args","numericLiteral","addHelper","getLabel","label","registerLabel","specifier","unaryExpression","reassign","bindingPath","ReferenceError","declarators","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClass","superClass","isClassBody","method","elements","elem","prop","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","isPureish","crawl","programParent","ref","ensureBlock","unique","blockHoist","dataKey","declarPath","getData","setData","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","findParent","p","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","enumerable","_path","_scope","_hub","_context","noScope","VISITOR_KEYS","_default","hasDenylistedType","cheap","traverseFast","skipKeys","visit","clearNode","removeProperties","delete","tree","hasType","denylistTypes","denylist","SHOULD_SKIP","SHOULD_STOP","REMOVED","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","NodePath","_traverseFlags","def","undefined","SyntaxError","validate","inList","message","enabled","getPathLocation","code","v","targetNode","setup","typeKey","virtualType","TraversalContext","priorityQueue","notPriority","trap","shouldVisit","visitQueue","visited","WeakSet","resync","process","add","popContext","visitMultiple","visitSingle","_helperSplitExportDeclaration","renameVisitor","skip","Renamer","parentDeclar","maybeExportDeclar","find","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","forEach","c","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","callback","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","_pathCache$get","inheritLeadingComments","inheritTrailingComments","requeue","replaceWithSourceString","replacement","_parser","parse","err","_codeFrame","codeFrameColumns","start","column","removed","_index2","nodePath","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","oldNode","inheritsComments","removeComments","_replaceWith","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","hoistVariablesVisitor","completionRecords","loop","returnStatement","arrowFunctionToExpression","FUNCTION_TYPES","awaitExpression","replaceInline","VariableDeclaration","exprs","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","resolved","item","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","Math","pow","func","global","_evaluate","raw","str","cooked","expr","String","toComputedKey","stringLiteral","bodyNode","stringPath","arrowFunctionToShadowed","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","binaryExpression","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","isnt","equals","isType","isCompletionRecord","allowInsideFunction","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","match","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","skipKey","getScope","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","_this$opts","_removeFromScope","_callRemovalHooks","_remove","removeBinding","_removalHooks"],"mappings":"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","file":"static/js/vendors-runtime-traverse.78af5284.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction findBreak(statements) {\n  let breakStatement;\n\n  if (!Array.isArray(statements)) {\n    statements = [statements];\n  }\n\n  for (const statement of statements) {\n    if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {\n      breakStatement = findBreak(statement.get(\"body\"));\n    } else if (statement.isIfStatement()) {\n      var _findBreak;\n\n      breakStatement = (_findBreak = findBreak(statement.get(\"consequent\"))) != null ? _findBreak : findBreak(statement.get(\"alternate\"));\n    } else if (statement.isTryStatement()) {\n      var _findBreak2;\n\n      breakStatement = (_findBreak2 = findBreak(statement.get(\"block\"))) != null ? _findBreak2 : findBreak(statement.get(\"handler\"));\n    } else if (statement.isBreakStatement()) {\n      breakStatement = statement;\n    }\n\n    if (breakStatement) {\n      return breakStatement;\n    }\n  }\n\n  return null;\n}\n\nfunction completionRecordForSwitch(cases, paths) {\n  let isLastCaseWithConsequent = true;\n\n  for (let i = cases.length - 1; i >= 0; i--) {\n    const switchCase = cases[i];\n    const consequent = switchCase.get(\"consequent\");\n    let breakStatement = findBreak(consequent);\n\n    if (breakStatement) {\n      while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {\n        breakStatement = breakStatement.parentPath;\n      }\n\n      const prevSibling = breakStatement.getPrevSibling();\n\n      if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {\n        paths = addCompletionRecords(prevSibling, paths);\n        breakStatement.remove();\n      } else {\n        breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());\n        paths = addCompletionRecords(breakStatement, paths);\n      }\n    } else if (isLastCaseWithConsequent) {\n      const statementFinder = statement => !statement.isBlockStatement() || statement.get(\"body\").some(statementFinder);\n\n      const hasConsequent = consequent.some(statementFinder);\n\n      if (hasConsequent) {\n        paths = addCompletionRecords(consequent[consequent.length - 1], paths);\n        isLastCaseWithConsequent = false;\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  let paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isSwitchStatement()) {\n    paths = completionRecordForSwitch(this.get(\"cases\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecratedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecratedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecratedKey}`);\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _binding = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  Block(path) {\n    const paths = path.get(\"body\");\n\n    for (const bodyPath of paths) {\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    const parent = this.path.findParent(p => p.isScope());\n    return parent == null ? void 0 : parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, allowArrayLike) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (allowArrayLike) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isFunction()) {\n      if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n\n      const params = path.get(\"params\");\n\n      for (const param of params) {\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.default.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _generator = _interopRequireDefault(require(\"@babel/generator\"));\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst debug = (0, _debug.default)(\"babel\");\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst testing = process.env.NODE_ENV === \"test\";\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys == null ? void 0 : keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hoistVariablesVisitor = {\n  Function(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    const bindings = path.getBindingIdentifiers();\n\n    for (const key of Object.keys(bindings)) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    const exprs = [];\n\n    for (const declar of path.node.declarations) {\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n\n};\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        const callee = this.get(\"callee\");\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  const callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n\n  if (isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES)) {\n    callee.set(\"async\", true);\n    this.replaceWith(t.awaitExpression(this.node));\n  }\n\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding == null ? void 0 : binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperFunctionName = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (specCompliant) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, specCompliant = false, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => t.identifier(\"arguments\"));\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || specCompliant) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (specCompliant) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = require(\"./index\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = _interopRequireWildcard(require(\"./index\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}"],"sourceRoot":""}